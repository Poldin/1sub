---
title: "Credits and Subscriptions"
description: "Understanding the credit system and subscription model in 1Sub"
---

# Credits and Subscriptions

1Sub supports two monetization models: **credits** for usage-based pricing and **subscriptions** for recurring access. You can use either model or combine both.

## Subscription Model

Subscriptions provide recurring access to your tool at a fixed price per billing cycle.

### How Subscriptions Work

<Steps>
<Step title="User subscribes">
  User selects a plan and completes payment on 1Sub.
</Step>

<Step title="User links account">
  User links their 1Sub account to your tool via email or link code.
</Step>

<Step title="You verify subscription">
  Your tool verifies the subscription is active before granting access.
  
```typescript
const subscription = await verifySubscription(oneSubUserId);

if (subscription.active) {
  // Grant access to premium features
}
```
</Step>

<Step title="Subscription renews">
  1Sub handles billing automatically. You receive webhook notifications.
</Step>
</Steps>

### Subscription States

<ResponseField name="trialing" type="string">
User is in free trial period. Access should be granted.
</ResponseField>

<ResponseField name="active" type="string">
Subscription is active and paid. Access should be granted.
</ResponseField>

<ResponseField name="past_due" type="string">
Payment failed but within grace period. You can choose to grant or deny access.
</ResponseField>

<ResponseField name="canceled" type="string">
Subscription is canceled. Access should be denied.
</ResponseField>

<ResponseField name="incomplete" type="string">
Initial payment not yet completed. Access should be denied.
</ResponseField>

<ResponseField name="incomplete_expired" type="string">
Initial payment never completed. Access should be denied.
</ResponseField>

### Subscription Properties

When you verify a subscription, you receive:

<ResponseField name="active" type="boolean" required>
Whether the subscription allows access (true for `trialing`, `active`, or `past_due` within grace period)
</ResponseField>

<ResponseField name="status" type="string" required>
Current subscription state (see states above)
</ResponseField>

<ResponseField name="planId" type="string" required>
Plan identifier (e.g., `"monthly"`, `"annual"`, `"pro"`)
</ResponseField>

<ResponseField name="currentPeriodStart" type="string (ISO 8601)" required>
Start of current billing period
</ResponseField>

<ResponseField name="currentPeriodEnd" type="string (ISO 8601)" required>
End of current billing period (renewal date)
</ResponseField>

<ResponseField name="cancelAtPeriodEnd" type="boolean" required>
Whether subscription will cancel at the end of the current period
</ResponseField>

<ResponseField name="trialEndsAt" type="string (ISO 8601) | null">
When trial ends, if applicable
</ResponseField>

**Example response:**

```json
{
  "active": true,
  "status": "active",
  "planId": "monthly",
  "currentPeriodStart": "2025-11-01T00:00:00Z",
  "currentPeriodEnd": "2025-12-01T00:00:00Z",
  "cancelAtPeriodEnd": false,
  "trialEndsAt": null
}
```

### Plan Management

Users can:
- **Upgrade/downgrade** between your plans
- **Cancel** subscriptions (effective at period end)
- **Pause** subscriptions
- **Resume** canceled subscriptions

You'll receive webhooks for all these changes.

## Credit Model

Credits provide usage-based pricing where users pay upfront and consume credits as they use your tool.

### How Credits Work

<Steps>
<Step title="User purchases credits">
  User buys a credit package on 1Sub (e.g., 100 credits for $10).
</Step>

<Step title="User subscribes to tool">
  User links their account to your tool (via email or link code).
</Step>

<Step title="You consume credits">
  Each time user uses a feature, you consume credits via API:
  
```typescript
await consumeCredits({
  user_id: oneSubUserId,
  amount: 10,
  reason: 'Generated 1 image',
  idempotency_key: `${userId}-${requestId}`,
});
```
</Step>

<Step title="User runs out">
  When balance reaches zero, prompt user to purchase more credits.
</Step>
</Steps>

### Credit Consumption

**Endpoint:** `POST /api/v1/credits/consume`

<ParamField body="user_id" type="string (UUID)" required>
The 1Sub user ID whose credits to consume
</ParamField>

<ParamField body="amount" type="number" required>
Number of credits to consume (positive integer, max 1,000,000)
</ParamField>

<ParamField body="reason" type="string" required>
Description of what the credits were used for (1-500 characters)
</ParamField>

<ParamField body="idempotency_key" type="string" required>
Unique key to prevent duplicate charges (persisted for 24 hours)
</ParamField>

**Request example:**

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/credits/consume' \
  -H 'Authorization: Bearer sk-tool-xxxxx' \
  -H 'Content-Type: application/json' \
  -d '{
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "amount": 10,
    "reason": "Generated 1 AI image",
    "idempotency_key": "img-gen-user123-1234567890"
  }'
```
</RequestExample>

**Success response:**

<ResponseExample>
```json 200 OK
{
  "success": true,
  "transaction_id": "txn-abc123",
  "balance_before": 100,
  "new_balance": 90,
  "credits_consumed": 10
}
```
</ResponseExample>

**Error responses:**

<ResponseExample>
```json 400 Insufficient Credits
{
  "error": "Insufficient credits",
  "message": "User does not have sufficient credits",
  "current_balance": 5,
  "required": 10,
  "shortfall": 5
}
```
</ResponseExample>

### Idempotency

Use idempotency keys to prevent duplicate charges if requests are retried:

```typescript
// Good: Unique per operation
const idempotencyKey = `${operationType}-${userId}-${operationId}`;

// Bad: Not unique enough
const idempotencyKey = userId; // Will prevent all future charges!
```

<Tip>
Include operation type, user ID, and a unique operation identifier in your idempotency key.
</Tip>

### Credit Pricing

You set credit costs for your tool's features:

```typescript
const CREDIT_COSTS = {
  'image_generation': 10,
  'image_upscale': 5,
  'video_generation': 50,
  'api_call': 1,
};

async function generateImage(userId: string) {
  // Consume credits first
  const result = await consumeCredits({
    user_id: oneSubUserId,
    amount: CREDIT_COSTS.image_generation,
    reason: 'Generated 1 image',
    idempotency_key: `img-${userId}-${Date.now()}`,
  });
  
  try {
    // Perform operation
    const image = await yourImageGenerationService();
    return { image, creditsRemaining: result.new_balance };
  } catch (error) {
    // Operation failed - refund credits if needed
    console.error('Image generation failed:', error);
    throw error;
  }
}
```

<Warning>
Credits are consumed immediately and non-refundable by default. Handle failures gracefully.
</Warning>

## Hybrid Model

Combine subscriptions and credits for maximum flexibility:

<Tabs>
<Tab title="Subscription + Usage Credits">
  **Pattern:** Subscription grants base access, credits used for premium features
  
  - User subscribes for base tier
  - Purchases credits for premium features (AI generations, etc.)
  - Verify subscription for access, consume credits for usage
  
```typescript
async function handleRequest(userId: string) {
  // Check subscription for access
  const sub = await verifySubscription(oneSubUserId);
  if (!sub.active) {
    throw new Error('Subscription required');
  }
  
  // Consume credits for usage
  await consumeCredits({
    user_id: oneSubUserId,
    amount: 10,
    reason: 'Used premium feature',
    idempotency_key: `${userId}-${requestId}`,
  });
}
```
</Tab>

<Tab title="Subscription Includes Credits">
  **Pattern:** Subscription grants monthly credit allowance
  
  - User subscribes and receives X credits per month
  - Credits reset at billing cycle
  - Can purchase additional credits if needed
  
```typescript
async function handleRequest(userId: string) {
  const sub = await verifySubscription(oneSubUserId);
  
  if (!sub.active) {
    throw new Error('Subscription required');
  }
  
  // Check included credits
  if (sub.creditsRemaining > 0) {
    // Consume from subscription allowance
    await consumeCredits({ ... });
  } else {
    // Prompt to purchase additional credits
    throw new Error('Monthly credits exhausted');
  }
}
```
</Tab>

<Tab title="Tiered Subscriptions">
  **Pattern:** Different plans with different credit allowances
  
  - Basic: 100 credits/month
  - Pro: 500 credits/month
  - Enterprise: Unlimited
  
```typescript
const PLAN_LIMITS = {
  'basic': 100,
  'pro': 500,
  'enterprise': Infinity,
};

async function handleRequest(userId: string) {
  const sub = await verifySubscription(oneSubUserId);
  
  if (!sub.active) {
    throw new Error('Subscription required');
  }
  
  const limit = PLAN_LIMITS[sub.planId];
  if (sub.creditsRemaining < 10 && limit !== Infinity) {
    throw new Error('Credit limit reached for your plan');
  }
  
  await consumeCredits({ ... });
}
```
</Tab>
</Tabs>

## Best Practices

<AccordionGroup>
<Accordion title="Cache subscription status">
Don't verify subscriptions on every request. Cache and update via webhooks:

```typescript
const subscriptionCache = new Map();

// Cache subscription
subscriptionCache.set(oneSubUserId, {
  data: subscription,
  cachedAt: Date.now(),
});

// Update on webhook
webhookHandler.on('subscription.updated', (event) => {
  subscriptionCache.delete(event.data.oneSubUserId);
});
```
</Accordion>

<Accordion title="Handle insufficient credits gracefully">
Show clear error messages and provide a way to purchase more:

```typescript
try {
  await consumeCredits({ ... });
} catch (error) {
  if (error.response?.status === 400) {
    return {
      error: 'insufficient_credits',
      message: 'You need 10 more credits to use this feature.',
      purchaseUrl: 'https://1sub.io/buy-credits',
      currentBalance: error.response.data.current_balance,
      required: error.response.data.required,
    };
  }
}
```
</Accordion>

<Accordion title="Consume credits before performing operations">
Always deduct credits before expensive operations to prevent free usage if the operation fails:

```typescript
// Good
await consumeCredits({ amount: 10, ... });
const result = await expensiveOperation();

// Bad - user gets free usage if operation succeeds
const result = await expensiveOperation();
await consumeCredits({ amount: 10, ... }); // Might never execute
```
</Accordion>

<Accordion title="Use descriptive reasons">
Help users understand their credit usage:

```typescript
// Good
reason: 'Generated 1024x1024 image with "sunset landscape" prompt'

// Bad
reason: 'API call'
```
</Accordion>

<Accordion title="Handle subscription grace periods">
Decide how to treat `past_due` subscriptions:

```typescript
const sub = await verifySubscription(oneSubUserId);

if (sub.status === 'past_due') {
  // Option 1: Grant access with warning
  showWarning('Payment failed. Please update your payment method.');
  
  // Option 2: Deny access
  throw new Error('Subscription payment failed');
}
```
</Accordion>
</AccordionGroup>

## Monitoring Usage

Track credit consumption and subscription metrics:

```typescript
// Log credit consumption
console.log(`[CREDITS] User ${oneSubUserId} consumed ${amount} credits for: ${reason}`);

// Track subscription changes
webhookHandler.on('subscription.canceled', (event) => {
  analytics.track('Subscription Canceled', {
    userId: event.data.oneSubUserId,
    planId: event.data.planId,
    reason: event.data.cancellationReason,
  });
});
```

<Check>
Proper monitoring helps you optimize pricing and understand user behavior.
</Check>

## One-Time Purchase Model

One-time purchases allow users to buy lifetime access to your tool for a single payment, without recurring charges.

### How One-Time Purchases Work

<Steps>
<Step title="User purchases tool">
  User pays once for lifetime access on 1Sub.
</Step>

<Step title="Purchase webhook sent">
  You receive `purchase.completed` webhook event.
</Step>

<Step title="You verify ownership">
  Verify the user owns your tool before granting access:

```typescript
const subscription = await verifySubscription(oneSubUserId);

if (subscription.hasLifetimeAccess) {
  // Grant permanent access to all features
}
```
</Step>

<Step title="User has lifetime access">
  User can use your tool forever without recurring payments.
</Step>
</Steps>

### One-Time Purchase Properties

When you verify a subscription, you'll receive these fields for one-time purchases:

<ResponseField name="hasLifetimeAccess" type="boolean" required>
Whether user has lifetime access via one-time purchase
</ResponseField>

<ResponseField name="purchaseDate" type="string (ISO 8601)">
When the one-time purchase was completed
</ResponseField>

<ResponseField name="purchaseAmount" type="number">
Amount paid for lifetime access (in cents)
</ResponseField>

**Example response:**

```json
{
  "active": false,
  "status": "none",
  "hasLifetimeAccess": true,
  "purchaseDate": "2025-11-16T12:34:56Z",
  "purchaseAmount": 9900,
  "oneSubUserId": "uuid-abc-123"
}
```

### When to Use One-Time Purchases

<CardGroup cols={2}>
<Card title="Best For" icon="check">
  - Desktop applications
  - CLI tools and utilities
  - Mobile apps
  - Templates and themes
  - Educational content
  - Tools with minimal ongoing costs
</Card>

<Card title="Not Recommended For" icon="x">
  - SaaS with high server costs
  - Tools requiring continuous updates
  - API services with per-use costs
  - Team collaboration platforms
</Card>
</CardGroup>

### Pricing Strategies

Recommended pricing for one-time purchases:

<Tip>
Price your lifetime access at 12-24 months of subscription value. Example: If your monthly plan is $10, price lifetime at $120-240.
</Tip>

### Webhooks for One-Time Purchases

Listen for `purchase.completed` event to grant lifetime access:

```typescript
webhookHandler.on('purchase.completed', (event) => {
  console.log('New purchase:', event.data);

  // {
  //   oneSubUserId: "uuid-abc-123",
  //   toolId: "uuid-tool-456",
  //   amount: 9900, // $99.00 in cents
  //   purchaseDate: "2025-11-16T12:34:56Z"
  // }

  // Grant lifetime access
  await db.users.update(event.data.oneSubUserId, {
    hasLifetimeAccess: true,
    purchaseDate: event.data.purchaseDate
  });

  // Send welcome email
  await sendWelcomeEmail(event.data.oneSubUserId);
});
```

### Hybrid: One-Time + Credits

You can combine one-time purchases with credits for flexible pricing:

```typescript
async function handleRequest(userId: string) {
  const sub = await verifySubscription(oneSubUserId);

  // Check for lifetime access OR active subscription
  if (!sub.hasLifetimeAccess && !sub.active) {
    throw new Error('Purchase or subscription required');
  }

  // User has access, now consume credits for usage
  await consumeCredits({
    user_id: oneSubUserId,
    amount: 10,
    reason: 'Used premium feature',
    idempotency_key: `${userId}-${requestId}`,
  });
}
```

<Note>
See [Monetization Models](/concepts/monetization-models) for a complete comparison of subscriptions, credits, and one-time purchases.
</Note>

## Credit Notifications via Webhooks

1Sub automatically sends webhook notifications when users' credit balances change:

**Low Credit Warning** (`user.credit_low`)
- Sent when balance drops to 10 or fewer credits
- Only fires once when crossing the threshold
- Use to prompt users to purchase more credits

**Credits Depleted** (`user.credit_depleted`)
- Sent when balance reaches exactly 0
- Use to suspend credit-based features
- Show urgent purchase prompts

See [Webhook Events](/webhooks/events#user-credit-low) for complete documentation and handler examples.


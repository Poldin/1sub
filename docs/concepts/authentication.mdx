---
title: "Authentication"
description: "Understanding authentication methods and security in 1Sub integrations"
---

# Authentication

1Sub uses two primary authentication methods: JWT tokens for user authentication and API keys for server-to-server requests.

## JWT Tokens (User Authentication)

When users subscribe to your tool on 1Sub, they're redirected to your application with a short-lived JWT (JSON Web Token).

### Token Format

```
https://yourtool.com/callback?token=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImtleS0yMDI1LTAxIn0...
```

### Token Claims

The JWT contains the following claims:

<ResponseField name="iss" type="string" required>
Issuer, always `"1sub"`
</ResponseField>

<ResponseField name="aud" type="string" required>
Audience, your tool ID (UUID format)
</ResponseField>

<ResponseField name="sub" type="string" required>
Subject, the 1Sub user ID (UUID format)
</ResponseField>

<ResponseField name="email" type="string" required>
User's email address
</ResponseField>

<ResponseField name="jti" type="string" required>
JWT ID for replay protection (unique per token)
</ResponseField>

<ResponseField name="iat" type="number" required>
Issued at timestamp (Unix time)
</ResponseField>

<ResponseField name="exp" type="number" required>
Expiration timestamp (Unix time, 10 minutes from issue)
</ResponseField>

## Token Verification Methods

1Sub offers two methods to verify JWT tokens. Choose based on your needs:

### Method 1: JWKS Verification (Recommended)

**Best for:** Most integrations, especially high-volume APIs

**Advantages:**
- ✅ Faster (no network call required)
- ✅ Better security (client-side verification)
- ✅ Works offline once JWKS is cached
- ✅ Reduces load on 1Sub servers

Verify JWT signatures using the public keys from our JWKS endpoint:

```
https://1sub.io/.well-known/1sub-jwks.json
```

<Tip>
Cache the JWKS response for up to 1 hour to reduce latency and API calls.
</Tip>

**Example verification:**

<CodeGroup>
```typescript Node.js (jose)
import { jwtVerify, createRemoteJWKSet } from 'jose';

const JWKS = createRemoteJWKSet(
  new URL('https://1sub.io/.well-known/1sub-jwks.json')
);

async function verifyToken(token: string, toolId: string) {
  try {
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: '1sub',
      audience: toolId,
      maxTokenAge: '10m',
    });
    
    return {
      oneSubUserId: payload.sub as string,
      email: payload.email as string,
      jti: payload.jti as string,
    };
  } catch (error) {
    console.error('JWT verification failed:', error);
    return null;
  }
}
```

```python Python (jose)
from jose import jwt, jwk
import requests

# Fetch JWKS (cache this!)
jwks_response = requests.get('https://1sub.io/.well-known/1sub-jwks.json')
JWKS = jwks_response.json()

def verify_token(token, tool_id):
    try:
        claims = jwt.decode(
            token,
            JWKS,
            algorithms=['RS256'],
            audience=tool_id,
            issuer='1sub'
        )
        
        return {
            'onesub_user_id': claims['sub'],
            'email': claims['email'],
            'jti': claims['jti']
        }
    except Exception as e:
        print(f'JWT verification failed: {e}')
        return None
```
</CodeGroup>

### Method 2: API Verification (Alternative)

**Best for:** Simpler integrations, legacy systems, or when JWKS libraries are unavailable

**Advantages:**
- ✅ Simple implementation (just an API call)
- ✅ No JWT libraries required
- ✅ Server-side validation handles all complexity

**Disadvantages:**
- ⚠️ Requires network call (adds latency)
- ⚠️ Rate limited (60 requests/minute per IP)
- ⚠️ Dependent on 1Sub availability

Use the `/api/v1/verify-user` endpoint to verify tokens:

<CodeGroup>
```typescript Node.js
async function verifyTokenViaAPI(token: string) {
  const response = await fetch('https://1sub.io/api/v1/verify-user', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ token })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message);
  }
  
  return await response.json(); // { valid, user_id, tool_id, checkout_id, expires_at }
}
```

```python Python
import requests

def verify_token_via_api(token):
    response = requests.post(
        'https://1sub.io/api/v1/verify-user',
        json={'token': token}
    )
    
    if not response.ok:
        raise Exception(response.json().get('message', 'Verification failed'))
    
    return response.json()  # { valid, user_id, tool_id, checkout_id, expires_at }
```
</CodeGroup>

<Note>
For complete API documentation, see [Verify User Token](/api/reference#verify-user-token).
</Note>

### Which Method Should You Use?

<CardGroup cols={2}>
<Card title="Use JWKS if..." icon="check">
- You have high request volume
- Performance is critical
- You can use JWT libraries (jose, PyJWT, etc.)
- You want offline verification capability
</Card>

<Card title="Use API verification if..." icon="bolt">
- You're building a quick prototype
- JWT libraries aren't available
- Request volume is low (&lt;60/min)
- You prefer simplicity over performance
</Card>
</CardGroup>

### Token Security Best Practices

<AccordionGroup>
<Accordion title="Always verify signatures">
Never trust JWT tokens without verifying the signature using JWKS. This prevents token tampering.
</Accordion>

<Accordion title="Check expiration">
Reject expired tokens immediately. Our tokens expire after 10 minutes.
</Accordion>

<Accordion title="Validate claims">
Always check `iss`, `aud`, and `exp` claims. Mismatch indicates an invalid or misrouted token.
</Accordion>

<Accordion title="Implement replay protection">
Store the `jti` (JWT ID) for processed tokens to prevent replay attacks. Tokens should only be processed once.

```typescript
const processedTokens = new Set();

if (processedTokens.has(payload.jti)) {
  throw new Error('Token already processed');
}
processedTokens.add(payload.jti);
```
</Accordion>
</AccordionGroup>

## API Keys (Server-to-Server)

For API requests from your server to 1Sub, use Bearer authentication with your API key.

### API Key Format

```
sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```

### Usage

Include the API key in the `Authorization` header:

```http
Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/tools/subscriptions/verify' \
  -H 'Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx' \
  -H 'Content-Type: application/json' \
  -d '{"oneSubUserId": "uuid-abc-123"}'
```
</RequestExample>

<ResponseExample>
```json Success
{
  "active": true,
  "status": "active",
  "planId": "monthly",
  "currentPeriodEnd": "2025-12-01T00:00:00Z"
}
```
</ResponseExample>

### Security Best Practices

<Warning>
API keys are shown **only once** in the vendor dashboard. If you lose your key, you must regenerate it.
</Warning>

<AccordionGroup>
<Accordion title="Store securely">
Always store API keys in environment variables or a secrets manager. Never hard-code them or commit to version control.

```bash
# .env
ONESUB_API_KEY=sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```
</Accordion>

<Accordion title="Use HTTPS only">
Only make API requests over HTTPS. Our API rejects non-HTTPS requests.
</Accordion>

<Accordion title="Rotate on compromise">
If an API key is exposed, regenerate it immediately from the vendor dashboard.
</Accordion>

<Accordion title="Server-side only">
Never expose API keys in client-side code. All API calls should be made from your server.
</Accordion>
</AccordionGroup>

## Webhook Signatures (HMAC)

Webhooks from 1Sub include an HMAC-SHA256 signature for verification.

### Signature Format

```http
1sub-signature: t=1700000000,v1=abcdef123456789...
```

- `t`: Unix timestamp when the webhook was sent
- `v1`: HMAC-SHA256 signature hex string

### Verification Process

<Steps>
<Step title="Extract signature components">
Parse the `1sub-signature` header:

```typescript
const parts = signature.split(',');
const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
```
</Step>

<Step title="Check timestamp freshness">
Reject webhooks older than 5 minutes (replay protection):

```typescript
const now = Math.floor(Date.now() / 1000);
if (Math.abs(now - parseInt(timestamp)) > 300) {
  throw new Error('Webhook too old');
}
```
</Step>

<Step title="Compute expected signature">
Create HMAC signature of `timestamp.payload`:

```typescript
import crypto from 'crypto';

const signedPayload = `${timestamp}.${rawBody}`;
const expected = crypto
  .createHmac('sha256', process.env.ONESUB_WEBHOOK_SECRET)
  .update(signedPayload)
  .digest('hex');
```

<Warning>
You must use the **raw request body** (not parsed JSON) for signature verification.
</Warning>
</Step>

<Step title="Compare signatures safely">
Use timing-safe comparison to prevent timing attacks:

```typescript
const isValid = crypto.timingSafeEqual(
  Buffer.from(expected),
  Buffer.from(sig)
);
```
</Step>
</Steps>

### Complete Example

<CodeGroup>
```typescript Node.js
import crypto from 'crypto';
import express from 'express';

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !sig) return false;
  
  // Check timestamp (within 5 minutes)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;
  
  // Compute signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

// Webhook endpoint
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }), // Get raw body
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();
    
    if (!verifyWebhookSignature(payload, signature, process.env.ONESUB_WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }
    
    // Process webhook
    const event = JSON.parse(payload);
    console.log('Valid webhook:', event.type);
    
    res.json({ received: true });
  }
);
```

```python Python
import hmac
import hashlib
import time
from flask import Flask, request, jsonify

app = Flask(__name__)

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')
    
    if not timestamp or not sig:
        return False
    
    # Check timestamp
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False
    
    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)
    
    if not verify_webhook_signature(
        payload,
        signature,
        os.environ['ONESUB_WEBHOOK_SECRET']
    ):
        return 'Invalid signature', 401
    
    # Process webhook
    event = request.get_json()
    print(f"Valid webhook: {event['type']}")
    
    return jsonify({'received': True})
```
</CodeGroup>

## Security Checklist

Before going to production, ensure you:

- ✅ Verify all JWT signatures using JWKS
- ✅ Check JWT expiration and claims (`iss`, `aud`, `exp`)
- ✅ Implement JWT replay protection using `jti`
- ✅ Store API keys securely in environment variables
- ✅ Use HTTPS for all API requests
- ✅ Verify all webhook signatures
- ✅ Reject old webhooks (timestamp check)
- ✅ Use raw request body for webhook verification
- ✅ Never expose credentials in client-side code
- ✅ Rotate API keys if compromised

<Check>
Following these practices ensures your integration is secure and production-ready.
</Check>


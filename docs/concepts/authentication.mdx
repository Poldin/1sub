---
title: "Authentication"
description: "Understanding authentication methods and security in 1Sub integrations"
---

# Authentication

1Sub uses two primary authentication methods for tool integrations:

1. **Email-Based Verification** - For SaaS tools with their own authentication
2. **Link Codes** - For CLI tools, desktop apps, or any tool where email-based verification isn't suitable

Both methods use your API key for server-to-server authentication.

## Email-Based Verification (Recommended for SaaS)

**Best for:** Web applications, SaaS tools, platforms with their own user authentication

When your tool already has authenticated users with verified emails, you can seamlessly link their 1Sub accounts using email-based verification.

### How It Works

<Steps>
<Step title="User subscribes on 1Sub">
User purchases a subscription to your tool through 1Sub and provides their email address.
</Step>

<Step title="User logs into your tool">
User logs into your tool with the same email address they used on 1Sub.
</Step>

<Step title="Your tool verifies subscription">
Hash the user's email and call the verify endpoint to get their `oneSubUserId` and subscription status.
</Step>

<Step title="Cache the oneSubUserId">
Store the `oneSubUserId` for future verification calls (much faster than email lookups).
</Step>
</Steps>

### Implementation Example

<CodeGroup>
```typescript Node.js
import crypto from 'crypto';

async function linkUserAccount(userEmail: string, apiKey: string) {
  // 1. Hash the email (SHA256)
  const normalizedEmail = userEmail.toLowerCase().trim();
  const emailHash = crypto
    .createHash('sha256')
    .update(normalizedEmail)
    .digest('hex');

  // 2. Verify subscription and get oneSubUserId
  const response = await fetch('https://1sub.io/api/v1/tools/subscriptions/verify', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ emailSha256: emailHash })
  });

  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('No active subscription found for this email');
    }
    throw new Error('Failed to verify subscription');
  }

  const data = await response.json();

  // 3. Cache oneSubUserId for future verifications
  await db.users.update(userEmail, {
    oneSubUserId: data.oneSubUserId,
    subscriptionStatus: data.status,
    creditsRemaining: data.creditsRemaining
  });

  return data;
}

// For future verifications, use the cached oneSubUserId (10x faster)
async function checkSubscription(oneSubUserId: string, apiKey: string) {
  const response = await fetch('https://1sub.io/api/v1/tools/subscriptions/verify', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ oneSubUserId })
  });

  return await response.json();
}
```

```python Python
import hashlib
import requests

def link_user_account(user_email: str, api_key: str):
    # 1. Hash the email (SHA256)
    normalized_email = user_email.lower().strip()
    email_hash = hashlib.sha256(normalized_email.encode()).hexdigest()

    # 2. Verify subscription and get oneSubUserId
    response = requests.post(
        'https://1sub.io/api/v1/tools/subscriptions/verify',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={'emailSha256': email_hash}
    )

    if response.status_code == 404:
        raise Exception('No active subscription found for this email')

    response.raise_for_status()
    data = response.json()

    # 3. Cache oneSubUserId for future verifications
    db.users.update(user_email, {
        'onesub_user_id': data['oneSubUserId'],
        'subscription_status': data['status'],
        'credits_remaining': data['creditsRemaining']
    })

    return data

# For future verifications, use the cached oneSubUserId (10x faster)
def check_subscription(onesub_user_id: str, api_key: str):
    response = requests.post(
        'https://1sub.io/api/v1/tools/subscriptions/verify',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={'oneSubUserId': onesub_user_id}
    )

    return response.json()
```
</CodeGroup>

<Tip>
**Performance Optimization:** The first email lookup creates an automatic link. Subsequent verifications should use the cached `oneSubUserId` for 10-20x faster response times.
</Tip>

### Security Considerations

<AccordionGroup>
<Accordion title="Email verification is critical">
Only use this method if you've verified the user's email address through your own authentication system (e.g., email confirmation during signup). Never accept email addresses from unverified sources.
</Accordion>

<Accordion title="Rate limiting">
Email-based lookups are rate limited to 30 requests/minute per tool. Use the cached `oneSubUserId` for subsequent calls to avoid hitting rate limits.
</Accordion>

<Accordion title="Timing protection">
The API implements timing protection to prevent email enumeration attacks. All email lookups take a minimum of 100ms regardless of whether the email exists.
</Accordion>

<Accordion title="Email changes">
If a user changes their email on 1Sub, the link remains valid. The system maintains the connection via the `oneSubUserId`, not the email.
</Accordion>
</AccordionGroup>

## Link Codes (Alternative Method)

**Best for:** CLI tools, desktop applications, mobile apps, or when email-based verification isn't suitable

Link codes provide a simple 6-character code that users can enter to connect their accounts.

### How It Works

<Steps>
<Step title="User subscribes on 1Sub">
After subscribing, the user receives a 6-character link code (e.g., `A3K9Z7`) valid for 10 minutes.
</Step>

<Step title="User enters code in your tool">
User opens your tool and navigates to the account linking section to enter the code.
</Step>

<Step title="Your tool exchanges the code">
Call the exchange endpoint with the code and your internal user ID to create the link.
</Step>

<Step title="Link established">
The API returns the `oneSubUserId` which you can use for future subscription verifications.
</Step>
</Steps>

### Implementation Example

<CodeGroup>
```typescript Node.js
async function exchangeLinkCode(code: string, toolUserId: string, apiKey: string) {
  const response = await fetch('https://1sub.io/api/v1/tools/link/exchange-code', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      code: code.toUpperCase(), // Codes are case-insensitive
      toolUserId: toolUserId
    })
  });

  if (!response.ok) {
    const error = await response.json();
    if (response.status === 404) {
      throw new Error('Invalid or expired code');
    }
    throw new Error(error.message);
  }

  const data = await response.json();

  // Store oneSubUserId for future verification
  await db.users.update(toolUserId, {
    oneSubUserId: data.oneSubUserId,
    linkedAt: data.linkedAt
  });

  return data; // { linked: true, oneSubUserId, toolUserId, linkedAt }
}
```

```python Python
import requests

def exchange_link_code(code: str, tool_user_id: str, api_key: str):
    response = requests.post(
        'https://1sub.io/api/v1/tools/link/exchange-code',
        headers={
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        },
        json={
            'code': code.upper(),  # Codes are case-insensitive
            'toolUserId': tool_user_id
        }
    )

    if response.status_code == 404:
        raise Exception('Invalid or expired code')

    response.raise_for_status()
    data = response.json()

    # Store oneSubUserId for future verification
    db.users.update(tool_user_id, {
        'onesub_user_id': data['oneSubUserId'],
        'linked_at': data['linkedAt']
    })

    return data  # { linked: true, oneSubUserId, toolUserId, linkedAt }
```
</CodeGroup>

<Note>
Link codes are **single-use** and expire after **10 minutes**. Users can generate new codes from their 1Sub account if needed.
</Note>

### Link Code Best Practices

<AccordionGroup>
<Accordion title="Validate format">
Link codes are 6-10 uppercase alphanumeric characters. Validate the format before calling the API to provide immediate feedback to users.

```typescript
const CODE_REGEX = /^[A-Z0-9]{6,10}$/;
if (!CODE_REGEX.test(code)) {
  throw new Error('Invalid code format');
}
```
</Accordion>

<Accordion title="Handle expiration gracefully">
If a code has expired (404 response), prompt the user to generate a new code from their 1Sub account settings.
</Accordion>

<Accordion title="Idempotent exchange">
The code exchange endpoint is idempotent. If the same `toolUserId` attempts to exchange a code multiple times, it will return the existing link without error.
</Accordion>

<Accordion title="Store oneSubUserId">
After successful exchange, always store the `oneSubUserId` for future subscription verification calls. Don't rely on repeatedly exchanging codes.
</Accordion>
</AccordionGroup>

## API Keys (Server-to-Server)

For API requests from your server to 1Sub, use Bearer authentication with your API key.

### API Key Format

```
sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```

### Usage

Include the API key in the `Authorization` header:

```http
Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/tools/subscriptions/verify' \
  -H 'Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx' \
  -H 'Content-Type: application/json' \
  -d '{"oneSubUserId": "uuid-abc-123"}'
```
</RequestExample>

<ResponseExample>
```json Success
{
  "active": true,
  "status": "active",
  "planId": "monthly",
  "currentPeriodEnd": "2025-12-01T00:00:00Z"
}
```
</ResponseExample>

### Security Best Practices

<Warning>
API keys are shown **only once** in the vendor dashboard. If you lose your key, you must regenerate it.
</Warning>

<AccordionGroup>
<Accordion title="Store securely">
Always store API keys in environment variables or a secrets manager. Never hard-code them or commit to version control.

```bash
# .env
ONESUB_API_KEY=sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
```
</Accordion>

<Accordion title="Use HTTPS only">
Only make API requests over HTTPS. Our API rejects non-HTTPS requests.
</Accordion>

<Accordion title="Rotate on compromise">
If an API key is exposed, regenerate it immediately from the vendor dashboard.
</Accordion>

<Accordion title="Server-side only">
Never expose API keys in client-side code. All API calls should be made from your server.
</Accordion>
</AccordionGroup>

## Webhook Signatures (HMAC)

Webhooks from 1Sub include an HMAC-SHA256 signature for verification.

### Signature Format

```http
1sub-signature: t=1700000000,v1=abcdef123456789...
```

- `t`: Unix timestamp when the webhook was sent
- `v1`: HMAC-SHA256 signature hex string

### Verification Process

<Steps>
<Step title="Extract signature components">
Parse the `1sub-signature` header:

```typescript
const parts = signature.split(',');
const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
```
</Step>

<Step title="Check timestamp freshness">
Reject webhooks older than 5 minutes (replay protection):

```typescript
const now = Math.floor(Date.now() / 1000);
if (Math.abs(now - parseInt(timestamp)) > 300) {
  throw new Error('Webhook too old');
}
```
</Step>

<Step title="Compute expected signature">
Create HMAC signature of `timestamp.payload`:

```typescript
import crypto from 'crypto';

const signedPayload = `${timestamp}.${rawBody}`;
const expected = crypto
  .createHmac('sha256', process.env.ONESUB_WEBHOOK_SECRET)
  .update(signedPayload)
  .digest('hex');
```

<Warning>
You must use the **raw request body** (not parsed JSON) for signature verification.
</Warning>
</Step>

<Step title="Compare signatures safely">
Use timing-safe comparison to prevent timing attacks:

```typescript
const isValid = crypto.timingSafeEqual(
  Buffer.from(expected),
  Buffer.from(sig)
);
```
</Step>
</Steps>

### Complete Example

<CodeGroup>
```typescript Node.js
import crypto from 'crypto';
import express from 'express';

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !sig) return false;
  
  // Check timestamp (within 5 minutes)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;
  
  // Compute signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

// Webhook endpoint
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }), // Get raw body
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();
    
    if (!verifyWebhookSignature(payload, signature, process.env.ONESUB_WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }
    
    // Process webhook
    const event = JSON.parse(payload);
    console.log('Valid webhook:', event.type);
    
    res.json({ received: true });
  }
);
```

```python Python
import hmac
import hashlib
import time
from flask import Flask, request, jsonify

app = Flask(__name__)

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')
    
    if not timestamp or not sig:
        return False
    
    # Check timestamp
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False
    
    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)
    
    if not verify_webhook_signature(
        payload,
        signature,
        os.environ['ONESUB_WEBHOOK_SECRET']
    ):
        return 'Invalid signature', 401
    
    # Process webhook
    event = request.get_json()
    print(f"Valid webhook: {event['type']}")
    
    return jsonify({'received': True})
```
</CodeGroup>

## Security Checklist

Before going to production, ensure you:

- ✅ Only use email-based verification with verified email addresses
- ✅ Cache `oneSubUserId` after first lookup for better performance
- ✅ Validate link code format before API calls
- ✅ Handle expired link codes gracefully
- ✅ Store API keys securely in environment variables
- ✅ Use HTTPS for all API requests
- ✅ Verify all webhook signatures
- ✅ Reject old webhooks (timestamp check)
- ✅ Use raw request body for webhook verification
- ✅ Never expose credentials in client-side code
- ✅ Rotate API keys if compromised

<Check>
Following these practices ensures your integration is secure and production-ready.
</Check>


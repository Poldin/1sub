---
title: "API Reference"
description: "Complete reference for all 1Sub API endpoints"
---

# API Reference

Complete documentation for all 1Sub vendor API endpoints.

<Note>
All endpoints require Bearer authentication with your tool's API key unless otherwise specified.
</Note>

## Exchange Authorization Code

Exchange a single-use authorization code for a long-lived verification token and user entitlements.

**Endpoint:** `POST /api/v1/authorize/exchange`

**Rate Limit:** 60 requests per minute

<ParamField header="Authorization" type="string" required>
Bearer token with your tool API key (format: `Bearer sk-tool-xxxxx`)
</ParamField>

<ParamField body="code" type="string" required>
The authorization code received from the redirect callback (60 second lifetime, single-use)
</ParamField>

<ParamField body="redirectUri" type="string (URL)">
Optional redirect URI for validation (must match the URI configured in dashboard if provided)
</ParamField>

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/authorize/exchange' \
  -H 'Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx' \
  -H 'Content-Type: application/json' \
  -d '{
    "code": "AUTH_CODE_FROM_REDIRECT",
    "redirectUri": "https://yourtool.com/auth/1sub/callback"
  }'
```

```javascript Node.js
const response = await fetch('https://1sub.io/api/v1/authorize/exchange', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    code: authCode,
    redirectUri: 'https://yourtool.com/auth/1sub/callback'
  })
});

const data = await response.json();
console.log(`User: ${data.onesubUserId}, Token: ${data.verificationToken}`);
```

```python Python
import requests

response = requests.post(
    'https://1sub.io/api/v1/authorize/exchange',
    json={
        'code': auth_code,
        'redirectUri': 'https://yourtool.com/auth/1sub/callback'
    },
    headers={
        'Authorization': f'Bearer {os.environ["ONESUB_API_KEY"]}',
        'Content-Type': 'application/json'
    }
)

data = response.json()
print(f"User: {data['onesubUserId']}, Token: {data['verificationToken']}")
```
</RequestExample>

<ResponseExample>
```json 200 OK - Success
{
  "valid": true,
  "grantId": "grant_abc123def456",
  "onesubUserId": "550e8400-e29b-41d4-a716-446655440000",
  "entitlements": {
    "planId": "pro",
    "creditsRemaining": 1000,
    "features": ["api_access", "priority_support"],
    "limits": {
      "requests_per_day": 10000,
      "team_seats": 5
    }
  },
  "verificationToken": "vt_long_verification_token_string",
  "expiresAt": 1735689600
}
```

```json 400 Bad Request - Invalid Code
{
  "valid": false,
  "error": "INVALID_CODE",
  "message": "Invalid or expired authorization code"
}
```

```json 401 Unauthorized
{
  "valid": false,
  "error": "UNAUTHORIZED",
  "message": "Invalid API key"
}
```

```json 403 Forbidden - Access Revoked
{
  "valid": false,
  "error": "ACCESS_REVOKED",
  "message": "User's access to this tool has been revoked"
}
```
</ResponseExample>

### Response Fields

<ResponseField name="valid" type="boolean" required>
Whether the exchange was successful
</ResponseField>

<ResponseField name="grantId" type="string" required>
Unique identifier for this authorization grant
</ResponseField>

<ResponseField name="onesubUserId" type="string (UUID)" required>
The 1Sub user ID. Store this to identify the user in your system.
</ResponseField>

<ResponseField name="entitlements" type="object" required>
User's current entitlements and access level

<Expandable title="Entitlements Object">
  <ResponseField name="planId" type="string | null">
  Current subscription plan ID (e.g., "pro", "enterprise", or null if no subscription)
  </ResponseField>

  <ResponseField name="creditsRemaining" type="number | null">
  Credits remaining for this user (null if not using credit-based billing)
  </ResponseField>

  <ResponseField name="features" type="string[]">
  Array of enabled feature flags for this user
  </ResponseField>

  <ResponseField name="limits" type="object">
  Usage limits and quotas (structure varies by tool)
  </ResponseField>
</Expandable>
</ResponseField>

<ResponseField name="verificationToken" type="string" required>
Long-lived verification token (30 day lifetime). Store this securely and use it for ongoing access verification.
</ResponseField>

<ResponseField name="expiresAt" type="number" required>
Unix timestamp when the verification token expires (30 days from issuance)
</ResponseField>

<Warning>
Authorization codes are **single-use** and expire after **60 seconds**. Exchange them immediately upon receiving the redirect.
</Warning>

---

## Verify Access

Verify a verification token and check if the user still has active access. Returns updated entitlements and rotates the token if near expiry.

**Endpoint:** `POST /api/v1/verify`

**Rate Limit:** 120 requests per minute

<ParamField header="Authorization" type="string" required>
Bearer token with your tool API key
</ParamField>

<ParamField body="verificationToken" type="string" required>
The verification token obtained from `/authorize/exchange` or previous `/verify` call
</ParamField>

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/verify' \
  -H 'Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx' \
  -H 'Content-Type: application/json' \
  -d '{
    "verificationToken": "vt_long_verification_token_string"
  }'
```

```javascript Node.js
const response = await fetch('https://1sub.io/api/v1/verify', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    verificationToken: storedToken
  })
});

const data = await response.json();
if (data.valid) {
  console.log('Access granted');
  // Update token if rotated
  if (data.tokenRotated) {
    await updateStoredToken(data.verificationToken);
  }
}
```

```python Python
import requests

response = requests.post(
    'https://1sub.io/api/v1/verify',
    json={'verificationToken': stored_token},
    headers={
        'Authorization': f'Bearer {os.environ["ONESUB_API_KEY"]}',
        'Content-Type': 'application/json'
    }
)

data = response.json()
if data['valid']:
    print('Access granted')
    if data.get('tokenRotated'):
        update_stored_token(data['verificationToken'])
```
</RequestExample>

<ResponseExample>
```json 200 OK - Valid Access
{
  "valid": true,
  "onesubUserId": "550e8400-e29b-41d4-a716-446655440000",
  "entitlements": {
    "planId": "pro",
    "creditsRemaining": 950,
    "features": ["api_access", "priority_support"],
    "limits": {
      "requests_per_day": 10000
    }
  },
  "verificationToken": "vt_long_verification_token_string",
  "cacheUntil": 1735689000,
  "nextVerificationBefore": 1735690800,
  "tokenRotated": false
}
```

```json 200 OK - Token Rotated
{
  "valid": true,
  "onesubUserId": "550e8400-e29b-41d4-a716-446655440000",
  "entitlements": {
    "planId": "pro",
    "creditsRemaining": 950,
    "features": ["api_access"],
    "limits": {}
  },
  "verificationToken": "vt_new_rotated_token_string",
  "cacheUntil": 1735689000,
  "nextVerificationBefore": 1735690800,
  "tokenRotated": true
}
```

```json 401 Unauthorized - Invalid Token
{
  "valid": false,
  "error": "INVALID_TOKEN",
  "reason": "Verification token is invalid or malformed",
  "action": "terminate_session"
}
```

```json 401 Unauthorized - Expired Token
{
  "valid": false,
  "error": "TOKEN_EXPIRED",
  "reason": "Verification token has expired",
  "action": "terminate_session"
}
```

```json 403 Forbidden - Access Revoked
{
  "valid": false,
  "error": "ACCESS_REVOKED",
  "reason": "User's access has been revoked by admin",
  "revokedAt": 1735680000,
  "action": "terminate_session"
}
```

```json 403 Forbidden - Subscription Inactive
{
  "valid": false,
  "error": "SUBSCRIPTION_INACTIVE",
  "reason": "Subscription is canceled",
  "action": "terminate_session"
}
```
</ResponseExample>

### Response Fields

<ResponseField name="valid" type="boolean" required>
Whether the verification token is valid and user has active access
</ResponseField>

<ResponseField name="onesubUserId" type="string (UUID)">
The 1Sub user ID (only present if valid=true)
</ResponseField>

<ResponseField name="entitlements" type="object">
User's current entitlements (only present if valid=true, same structure as `/authorize/exchange`)
</ResponseField>

<ResponseField name="verificationToken" type="string">
Current verification token. If `tokenRotated` is true, this is a new token that should replace the old one.
</ResponseField>

<ResponseField name="cacheUntil" type="number">
Unix timestamp until which cached entitlements remain authoritative. Cache verification results until this time.
</ResponseField>

<ResponseField name="nextVerificationBefore" type="number">
Unix timestamp before which you should verify again (typically 30 minutes)
</ResponseField>

<ResponseField name="tokenRotated" type="boolean">
True if a new verification token was issued. Update your stored token if true.
</ResponseField>

<ResponseField name="error" type="string">
Error code if valid=false
</ResponseField>

<ResponseField name="reason" type="string">
Human-readable error message
</ResponseField>

<ResponseField name="action" type="string">
Recommended action: "terminate_session" or "reauthenticate"
</ResponseField>

<Tip>
Cache verification results using the `cacheUntil` timestamp to minimize API calls. Update the cache when you receive webhook notifications.
</Tip>

---

## Consume Credits

Deduct credits from a user's balance for tool usage.

**Endpoint:** `POST /api/v1/credits/consume`

**Rate Limit:** 100 requests per minute

<ParamField header="Authorization" type="string" required>
Bearer token with your tool API key
</ParamField>

<ParamField body="user_id" type="string (UUID)" required>
The 1Sub user ID (onesubUserId) whose credits to consume
</ParamField>

<ParamField body="amount" type="number" required>
Number of credits to consume (positive integer, max 1,000,000)
</ParamField>

<ParamField body="reason" type="string" required>
Description of what credits were used for (1-500 characters)
</ParamField>

<ParamField body="idempotency_key" type="string" required>
Unique key to prevent duplicate charges (persisted for 24 hours)
</ParamField>

<RequestExample>
```bash cURL
curl -X POST 'https://1sub.io/api/v1/credits/consume' \
  -H 'Authorization: Bearer sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx' \
  -H 'Content-Type: application/json' \
  -d '{
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "amount": 10,
    "reason": "Generated 1 AI image (1024x1024)",
    "idempotency_key": "img-gen-user123-1702345678"
  }'
```

```javascript Node.js
const response = await fetch('https://1sub.io/api/v1/credits/consume', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    user_id: oneSubUserId,
    amount: 10,
    reason: 'Generated 1 AI image',
    idempotency_key: `img-gen-${userId}-${Date.now()}`
  })
});

const result = await response.json();
console.log(`New balance: ${result.new_balance}`);
```

```python Python
import time

response = requests.post(
    'https://1sub.io/api/v1/credits/consume',
    json={
        'user_id': onesub_user_id,
        'amount': 10,
        'reason': 'Generated 1 AI image',
        'idempotency_key': f'img-gen-{user_id}-{int(time.time())}'
    },
    headers={
        'Authorization': f'Bearer {os.environ["ONESUB_API_KEY"]}',
        'Content-Type': 'application/json'
    }
)

result = response.json()
print(f"New balance: {result['new_balance']}")
```
</RequestExample>

<ResponseExample>
```json 200 OK - Success
{
  "success": true,
  "new_balance": 90,
  "transaction_id": "txn-abc123def456"
}
```

```json 200 OK - Duplicate Request (Idempotent)
{
  "success": true,
  "new_balance": 90,
  "transaction_id": "txn-abc123def456",
  "is_duplicate": true,
  "message": "This request has already been processed"
}
```

```json 402 Payment Required - Insufficient Credits
{
  "error": "Payment required",
  "message": "User does not have sufficient credits",
  "current_balance": 5,
  "required": 10,
  "shortfall": 5
}
```

```json 401 Unauthorized
{
  "error": "Invalid API key",
  "message": "The provided API key is invalid or does not exist"
}
```

```json 403 Forbidden - Access Revoked
{
  "error": "Forbidden",
  "message": "Access to this tool has been revoked",
  "reason": "Admin revoked access",
  "revoked_at": "2025-12-01T00:00:00Z",
  "action": "terminate_session"
}
```
</ResponseExample>

### Response Fields

<ResponseField name="success" type="boolean" required>
Whether credits were successfully consumed
</ResponseField>

<ResponseField name="new_balance" type="number" required>
User's credit balance after consumption
</ResponseField>

<ResponseField name="transaction_id" type="string" required>
Unique ID for this transaction
</ResponseField>

<ResponseField name="is_duplicate" type="boolean">
True if this request was a duplicate (idempotency key already used)
</ResponseField>

<Tip>
Always use idempotency keys to prevent double-charging users if requests are retried.
</Tip>

---

## Error Handling

All endpoints return standard error responses:

```json
{
  "error": "Error type",
  "message": "Human-readable message",
  "details": {}
}
```

### Common Error Codes

| Status | Error | Meaning | Action |
|--------|-------|---------|--------|
| 400 | Bad Request | Invalid parameters | Check request body and parameters |
| 401 | Unauthorized | Invalid/missing API key or token | Verify API key or re-authenticate user |
| 403 | Forbidden | Valid auth but access revoked/denied | Terminate user session, redirect to 1Sub |
| 404 | Not Found | Resource doesn't exist | Verify IDs are correct |
| 402 | Payment Required | Insufficient credits | Prompt user to purchase credits |
| 429 | Rate Limit Exceeded | Too many requests | Implement backoff, respect `Retry-After` |
| 500 | Internal Server Error | Server error | Retry with exponential backoff |

<Warning>
Always implement proper error handling and retry logic, especially for 429 and 500 errors.
</Warning>

## Rate Limit Headers

All authenticated endpoints return rate limit information:

```http
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 2025-12-01T12:35:00Z
```

Use these headers to track your usage and avoid hitting rate limits.

## Best Practices

<AccordionGroup>
<Accordion title="Cache Verification Results">
Use the `cacheUntil` field from `/verify` responses to cache results:

```typescript
const cache = new Map<string, { valid: boolean; cacheUntil: number }>();

async function verifyWithCache(token: string) {
  const cached = cache.get(token);
  if (cached && Date.now() / 1000 < cached.cacheUntil) {
    return cached.valid;
  }

  const result = await verifyToken(token);
  cache.set(token, {
    valid: result.valid,
    cacheUntil: result.cacheUntil
  });

  return result.valid;
}
```
</Accordion>

<Accordion title="Handle Token Rotation">
Always update your stored token when `tokenRotated` is true:

```typescript
const result = await verifyToken(currentToken);

if (result.tokenRotated) {
  // Old token will stop working soon, update to new one
  await db.users.update(userId, {
    verificationToken: result.verificationToken
  });
  session.verificationToken = result.verificationToken;
}
```
</Accordion>

<Accordion title="Use Idempotency Keys">
Always include idempotency keys when consuming credits:

```typescript
// Good: Unique per operation
const key = `operation-${userId}-${operationId}-${timestamp}`;

// Bad: Reused across operations
const key = userId; // Don't do this!
```
</Accordion>

<Accordion title="Respect Rate Limits">
Monitor rate limit headers and implement backoff:

```typescript
async function apiCall(url: string, body: any) {
  const response = await fetch(url, { method: 'POST', body });

  if (response.status === 429) {
    const retryAfter = response.headers.get('Retry-After');
    await sleep(parseInt(retryAfter || '60') * 1000);
    return apiCall(url, body); // Retry
  }

  return response.json();
}
```
</Accordion>
</AccordionGroup>

---
title: "Quickstart Guide"
description: "Get your tool integrated with 1Sub in under 15 minutes"
---

# Quickstart Guide

This guide will walk you through integrating your tool with 1Sub in three simple steps. By the end, you'll have user authentication, subscription verification, and webhooks fully configured.

<Note>
**Prerequisites**: Make sure you have your API key and webhook secret from the 1Sub vendor dashboard. If you haven't received these yet, publish your tool first.
</Note>

## Installation

First, install the required packages for JWT verification:

<CodeGroup>
```bash npm
npm install jose
```

```bash yarn
yarn add jose
```

```bash pnpm
pnpm add jose
```
</CodeGroup>

<Tip>
The `jose` library provides industry-standard JWT verification with JWKS support. It's lightweight and well-maintained.
</Tip>

## Step 1: Handle User Redirects

When users subscribe to your tool on 1Sub, they're redirected to your configured callback URL with a JWT token.

<Steps>
<Step title="Set up your callback endpoint">
  Create an endpoint to receive redirects from 1Sub:

```typescript
import { jwtVerify, createRemoteJWKSet } from 'jose';

const JWKS = createRemoteJWKSet(
  new URL('https://1sub.io/.well-known/1sub-jwks.json')
);

app.get('/auth/1sub/callback', async (req, res) => {
  const { token } = req.query;
  
  if (!token) {
    return res.status(400).send('Missing token');
  }
  
  // Continue to next step...
});
```
</Step>

<Step title="Verify the JWT token">
  Verify the token signature and extract user information:

```typescript
try {
  const { payload } = await jwtVerify(token as string, JWKS, {
    issuer: '1sub',
    audience: process.env.TOOL_ID, // Your tool ID
    maxTokenAge: '10m',
  });
  
  const oneSubUserId = payload.sub as string;
  const email = payload.email as string;
  
  // Continue to next step...
} catch (error) {
  console.error('JWT verification failed:', error);
  return res.status(401).send('Invalid token');
}
```

<Check>
The token is now verified and you have the user's 1Sub ID and email.
</Check>
</Step>

<Step title="Create or link your user">
  Map the 1Sub user ID to your internal user system:

```typescript
// Find or create user in your system
const user = await findOrCreateUser(email);

// Store the link between your user ID and 1Sub user ID
await storeUserLink(user.id, oneSubUserId);

// Create session and redirect
req.session.userId = user.id;
res.redirect('/dashboard');
```

<Tip>
Store the `oneSubUserId` â†’ your `userId` mapping in your database. You'll need this for subscription verification.
</Tip>
</Step>
</Steps>

<Note>
**Alternative: API Verification**

If you prefer not to use JWT libraries, you can verify tokens using our API endpoint:

```typescript
const response = await fetch('https://1sub.io/api/v1/verify-user', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ token })
});

const { user_id, tool_id, checkout_id } = await response.json();
```

This is simpler but adds network latency. See [Authentication Methods](/concepts/authentication#token-verification-methods) for a detailed comparison.
</Note>

## Step 2: Verify Subscriptions

Before granting access to premium features, verify that the user has an active subscription.

<Steps>
<Step title="Create a verification function">
  Set up a reusable function to check subscription status:

```typescript
import axios from 'axios';

async function verifySubscription(oneSubUserId: string) {
  const response = await axios.post(
    'https://1sub.io/api/v1/tools/subscriptions/verify',
    { oneSubUserId },
    {
      headers: {
        'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );
  
  return response.data;
}
```
</Step>

<Step title="Protect your premium endpoints">
  Add verification to your protected routes:

```typescript
app.post('/api/premium-feature', async (req, res) => {
  const userId = req.session.userId;
  
  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  // Get 1Sub user ID from your database
  const oneSubUserId = await getOneSubUserId(userId);
  
  try {
    const subscription = await verifySubscription(oneSubUserId);
    
    if (!subscription.active) {
      return res.status(403).json({
        error: 'Subscription required',
        status: subscription.status,
      });
    }
    
    // Grant access to feature
    const result = await yourPremiumFeature();
    res.json({ result });
    
  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(403).json({ error: 'No subscription found' });
    }
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});
```

<Check>
Your premium features are now protected by subscription verification.
</Check>
</Step>

<Step title="Cache subscription status (optional but recommended)">
  Reduce API calls by caching verification results:

```typescript
const cache = new Map();

async function getCachedSubscription(oneSubUserId: string) {
  if (cache.has(oneSubUserId)) {
    const cached = cache.get(oneSubUserId);
    if (Date.now() - cached.timestamp < 60000) { // 1 minute
      return cached.data;
    }
  }
  
  const data = await verifySubscription(oneSubUserId);
  cache.set(oneSubUserId, { data, timestamp: Date.now() });
  return data;
}
```

<Tip>
Update the cache when you receive webhook notifications to keep it fresh.
</Tip>
</Step>
</Steps>

## Step 3: Configure Webhooks

Receive real-time notifications when subscriptions change.

<Steps>
<Step title="Create webhook endpoint">
  Set up an endpoint to receive webhook events:

```typescript
import crypto from 'crypto';
import express from 'express';

app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();
    
    // Continue to next step...
  }
);
```

<Warning>
Use `express.raw()` middleware for webhook endpoints. You need the raw body to verify signatures.
</Warning>
</Step>

<Step title="Verify webhook signature">
  Validate that the webhook came from 1Sub:

```typescript
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !sig) return false;
  
  // Reject old timestamps (replay attack protection)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;
  
  // Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

// In your webhook handler:
if (!verifyWebhookSignature(payload, signature, process.env.ONESUB_WEBHOOK_SECRET)) {
  return res.status(401).send('Invalid signature');
}
```

<Check>
Webhooks are now authenticated and protected from replay attacks.
</Check>
</Step>

<Step title="Handle webhook events">
  Process different event types:

```typescript
const event = JSON.parse(payload);

switch (event.type) {
  case 'subscription.activated':
    console.log('Subscription activated:', event.data.oneSubUserId);
    // Clear cache, send welcome email, etc.
    cache.delete(event.data.oneSubUserId);
    break;
    
  case 'subscription.canceled':
    console.log('Subscription canceled:', event.data.oneSubUserId);
    // Revoke access, send cancellation email, etc.
    cache.delete(event.data.oneSubUserId);
    break;
    
  case 'subscription.updated':
    console.log('Subscription updated:', event.data.oneSubUserId);
    // Update cached status
    cache.delete(event.data.oneSubUserId);
    break;
}

res.json({ received: true });
```
</Step>

<Step title="Configure webhook URL in dashboard">
  Set your webhook URL in the 1Sub vendor dashboard:

```
https://yourtool.com/webhooks/1sub
```

<Tip>
Make sure your webhook endpoint is publicly accessible via HTTPS. Use ngrok for local testing.
</Tip>
</Step>
</Steps>

## Test Your Integration

<AccordionGroup>
<Accordion title="Test User Authentication">
  1. Subscribe to your tool on 1Sub (use test mode)
  2. Verify you're redirected to your callback URL with a token
  3. Check that the JWT is verified correctly
  4. Confirm user link is created in your database
</Accordion>

<Accordion title="Test Subscription Verification">
  1. Call your protected endpoint
  2. Verify it returns 403 for users without subscriptions
  3. Subscribe and verify it grants access
  4. Cancel subscription and verify access is revoked
</Accordion>

<Accordion title="Test Webhooks">
  1. Use a tool like RequestBin or ngrok for local testing
  2. Trigger events by creating/canceling subscriptions
  3. Verify signature validation works
  4. Check that events are processed correctly
  5. Test with invalid signatures (should return 401)
</Accordion>
</AccordionGroup>

## Complete Example

Here's a complete working example combining all three steps:

<CodeGroup>
```typescript Express + TypeScript
import express from 'express';
import axios from 'axios';
import { jwtVerify, createRemoteJWKSet } from 'jose';
import crypto from 'crypto';

const app = express();
const ONESUB_API_KEY = process.env.ONESUB_API_KEY;
const ONESUB_WEBHOOK_SECRET = process.env.ONESUB_WEBHOOK_SECRET;
const TOOL_ID = process.env.TOOL_ID;

const JWKS = createRemoteJWKSet(
  new URL('https://1sub.io/.well-known/1sub-jwks.json')
);

// Step 1: User Authentication
app.get('/auth/1sub/callback', async (req, res) => {
  const { token } = req.query;
  
  if (!token) {
    return res.status(400).send('Missing token');
  }
  
  try {
    const { payload } = await jwtVerify(token as string, JWKS, {
      issuer: '1sub',
      audience: TOOL_ID,
      maxTokenAge: '10m',
    });
    
    const oneSubUserId = payload.sub as string;
    const email = payload.email as string;
    
    const user = await findOrCreateUser(email);
    await storeUserLink(user.id, oneSubUserId);
    
    req.session.userId = user.id;
    res.redirect('/dashboard');
  } catch (error) {
    console.error('JWT verification failed:', error);
    res.status(401).send('Authentication failed');
  }
});

// Step 2: Subscription Verification
app.post('/api/premium-feature', async (req, res) => {
  const userId = req.session.userId;
  
  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  const oneSubUserId = await getOneSubUserId(userId);
  
  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/tools/subscriptions/verify',
      { oneSubUserId },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );
    
    if (!response.data.active) {
      return res.status(403).json({
        error: 'Subscription required',
        status: response.data.status,
      });
    }
    
    const result = await yourPremiumFeature();
    res.json({ result });
  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(403).json({ error: 'No subscription found' });
    }
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});

// Step 3: Webhook Handler
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();
    
    if (!verifyWebhookSignature(payload, signature, ONESUB_WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }
    
    const event = JSON.parse(payload);
    
    switch (event.type) {
      case 'subscription.activated':
        console.log('Subscription activated:', event.data.oneSubUserId);
        break;
      case 'subscription.canceled':
        console.log('Subscription canceled:', event.data.oneSubUserId);
        break;
      case 'subscription.updated':
        console.log('Subscription updated:', event.data.oneSubUserId);
        break;
    }
    
    res.json({ received: true });
  }
);

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !sig) return false;
  
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;
  
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

app.listen(3000);
```

```python Flask + Python
import os
import hmac
import hashlib
import time
import requests
from flask import Flask, request, session, redirect, jsonify
from jose import jwt, jwk
from jose.utils import base64url_decode

app = Flask(__name__)
app.secret_key = os.environ['SECRET_KEY']

ONESUB_API_KEY = os.environ['ONESUB_API_KEY']
ONESUB_WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']
TOOL_ID = os.environ['TOOL_ID']

# Fetch JWKS
jwks_response = requests.get('https://1sub.io/.well-known/1sub-jwks.json')
JWKS = jwks_response.json()

# Step 1: User Authentication
@app.route('/auth/1sub/callback')
def auth_callback():
    token = request.args.get('token')
    
    if not token:
        return 'Missing token', 400
    
    try:
        # Verify JWT
        claims = jwt.decode(
            token,
            JWKS,
            algorithms=['RS256'],
            audience=TOOL_ID,
            issuer='1sub'
        )
        
        onesub_user_id = claims['sub']
        email = claims['email']
        
        # Create or link user
        user = find_or_create_user(email)
        store_user_link(user['id'], onesub_user_id)
        
        session['user_id'] = user['id']
        return redirect('/dashboard')
        
    except Exception as e:
        print(f'JWT verification failed: {e}')
        return 'Authentication failed', 401

# Step 2: Subscription Verification
@app.route('/api/premium-feature', methods=['POST'])
def premium_feature():
    user_id = session.get('user_id')
    
    if not user_id:
        return jsonify({'error': 'Not authenticated'}), 401
    
    onesub_user_id = get_onesub_user_id(user_id)
    
    try:
        response = requests.post(
            'https://1sub.io/api/v1/tools/subscriptions/verify',
            json={'oneSubUserId': onesub_user_id},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()
        
        subscription = response.json()
        
        if not subscription['active']:
            return jsonify({
                'error': 'Subscription required',
                'status': subscription['status']
            }), 403
        
        result = your_premium_feature()
        return jsonify({'result': result})
        
    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return jsonify({'error': 'No subscription found'}), 403
        print(f'Verification failed: {e}')
        return jsonify({'error': 'Verification failed'}), 500

# Step 3: Webhook Handler
@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)
    
    if not verify_webhook_signature(payload, signature, ONESUB_WEBHOOK_SECRET):
        return 'Invalid signature', 401
    
    event = request.get_json()
    
    if event['type'] == 'subscription.activated':
        print(f"Subscription activated: {event['data']['oneSubUserId']}")
    elif event['type'] == 'subscription.canceled':
        print(f"Subscription canceled: {event['data']['oneSubUserId']}")
    elif event['type'] == 'subscription.updated':
        print(f"Subscription updated: {event['data']['oneSubUserId']}")
    
    return jsonify({'received': True})

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')
    
    if not timestamp or not sig:
        return False
    
    # Check timestamp
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False
    
    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

if __name__ == '__main__':
    app.run(port=3000)
```
</CodeGroup>

## Next Steps

<CardGroup cols={2}>
<Card title="Understand Core Concepts" icon="book" href="/concepts/authentication">
  Deep dive into authentication, user linking, and credits
</Card>

<Card title="Explore API Reference" icon="code" href="/api/reference">
  Complete documentation of all API endpoints
</Card>

<Card title="Configure Webhooks" icon="webhook" href="/webhooks/overview">
  Learn about webhook events and best practices
</Card>

<Card title="View More Examples" icon="file-code" href="/examples/node">
  Browse complete examples in multiple languages
</Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
<Accordion title="JWT Verification Fails">
  **Possible causes:**
  - Token has expired (10 minute lifetime)
  - `audience` doesn't match your tool ID
  - JWKS endpoint is unreachable
  
  **Solution:** Verify your tool ID is correct and the JWKS URL is accessible.
</Accordion>

<Accordion title="Subscription Not Found (404)">
  **Possible causes:**
  - User hasn't subscribed yet
  - Wrong `oneSubUserId` 
  - Tool ID mismatch
  
  **Solution:** Check the user link mapping in your database.
</Accordion>

<Accordion title="Webhook Signature Invalid">
  **Possible causes:**
  - Using parsed body instead of raw body
  - Wrong webhook secret
  - Timestamp too old (>5 minutes)
  
  **Solution:** Use `express.raw()` middleware and verify your webhook secret.
</Accordion>
</AccordionGroup>

<Warning>
Always store your API key and webhook secret securely in environment variables. Never commit them to version control.
</Warning>


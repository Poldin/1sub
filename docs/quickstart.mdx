---
title: "Quickstart Guide"
description: "Get your tool integrated with 1Sub in under 15 minutes"
---

# Quickstart Guide

This guide will walk you through integrating your tool with 1Sub in three simple steps. By the end, you'll have OAuth-like authorization, ongoing verification, and webhooks fully configured.

<Note>
**Prerequisites**: Make sure you have your API key and webhook secret from the 1Sub vendor dashboard. If you haven't received these yet, publish your tool first.
</Note>

## How 1Sub Authorization Works

1Sub uses an OAuth 2.0-like authorization flow that's simple and secure:

<Steps>
<Step title="User subscribes and launches">
  User subscribes to your tool on 1Sub and clicks "Launch Tool"
</Step>

<Step title="1Sub redirects with auth code">
  User is redirected to your configured redirect URI with a single-use authorization code
</Step>

<Step title="You exchange code for token">
  Your server exchanges the code for a long-lived verification token
</Step>

<Step title="Ongoing verification">
  Use the verification token to check access before serving premium features
</Step>
</Steps>

## Installation

No special libraries required! Just your favorite HTTP client:

<CodeGroup>
```bash npm
npm install axios  # or any HTTP client
```

```bash yarn
yarn add axios
```

```bash pnpm
pnpm add axios
```
</CodeGroup>

## Step 1: Configure Your Redirect URI

Set your redirect URI in the 1Sub vendor dashboard. This is where users will be sent after authorizing.

```
https://yourtool.com/auth/1sub/callback
```

<Warning>
The redirect URI must use HTTPS in production. Use `http://localhost` for local development only.
</Warning>

## Step 2: Handle the Authorization Callback

When a user launches your tool from 1Sub, they'll be redirected to your URI with an authorization code:

```
https://yourtool.com/auth/1sub/callback?code=AUTH_CODE&state=STATE
```

Create an endpoint to handle this callback:

<CodeGroup>
```typescript Express + TypeScript
import express from 'express';
import axios from 'axios';

const app = express();
const ONESUB_API_KEY = process.env.ONESUB_API_KEY;

app.get('/auth/1sub/callback', async (req, res) => {
  const { code, state } = req.query;

  if (!code) {
    return res.status(400).send('Missing authorization code');
  }

  try {
    // Exchange authorization code for verification token
    const response = await axios.post(
      'https://1sub.io/api/v1/authorize/exchange',
      {
        code: code as string,
        redirectUri: 'https://yourtool.com/auth/1sub/callback'
      },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const {
      verificationToken,
      onesubUserId,
      grantId,
      entitlements,
      expiresAt
    } = response.data;

    // Store verification token in user's session
    req.session.verificationToken = verificationToken;
    req.session.onesubUserId = onesubUserId;
    req.session.grantId = grantId;

    // Store in database for long-term access
    await db.users.upsert({
      onesubUserId,
      verificationToken,
      grantId,
      tokenExpiresAt: new Date(expiresAt * 1000),
      planId: entitlements.planId,
      creditsRemaining: entitlements.creditsRemaining,
      features: entitlements.features,
    });

    // Redirect to your tool's dashboard
    res.redirect('/dashboard');

  } catch (error) {
    console.error('Authorization exchange failed:', error);
    res.status(500).send('Authorization failed');
  }
});
```

```python Flask + Python
from flask import Flask, request, session, redirect
import requests
import os

app = Flask(__name__)
app.secret_key = os.environ['SECRET_KEY']

ONESUB_API_KEY = os.environ['ONESUB_API_KEY']

@app.route('/auth/1sub/callback')
def callback():
    code = request.args.get('code')
    state = request.args.get('state')

    if not code:
        return 'Missing authorization code', 400

    try:
        # Exchange authorization code for verification token
        response = requests.post(
            'https://1sub.io/api/v1/authorize/exchange',
            json={
                'code': code,
                'redirectUri': 'https://yourtool.com/auth/1sub/callback'
            },
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        data = response.json()

        # Store verification token in session
        session['verification_token'] = data['verificationToken']
        session['onesub_user_id'] = data['onesubUserId']
        session['grant_id'] = data['grantId']

        # Store in database
        db.users.upsert({
            'onesub_user_id': data['onesubUserId'],
            'verification_token': data['verificationToken'],
            'grant_id': data['grantId'],
            'token_expires_at': datetime.fromtimestamp(data['expiresAt']),
            'plan_id': data['entitlements']['planId'],
            'credits_remaining': data['entitlements']['creditsRemaining'],
        })

        # Redirect to dashboard
        return redirect('/dashboard')

    except requests.exceptions.HTTPError as e:
        print(f'Authorization exchange failed: {e}')
        return 'Authorization failed', 500
```
</CodeGroup>

<Check>
Users are now linked! The verification token is valid for 30 days and can be used for ongoing access checks.
</Check>

## Step 3: Verify Access Before Serving Features

Before serving premium features, verify the user still has access using their verification token:

<CodeGroup>
```typescript Express + TypeScript
app.post('/api/premium-feature', async (req, res) => {
  const verificationToken = req.session.verificationToken;

  if (!verificationToken) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    // Verify token and get current entitlements
    const response = await axios.post(
      'https://1sub.io/api/v1/verify',
      { verificationToken },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const { valid, entitlements, verificationToken: newToken } = response.data;

    if (!valid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Update token if rotated
    if (newToken !== verificationToken) {
      req.session.verificationToken = newToken;
      await db.users.updateToken(req.session.onesubUserId, newToken);
    }

    // Check entitlements (optional - based on your needs)
    if (entitlements.creditsRemaining !== null && entitlements.creditsRemaining < 10) {
      console.warn('User has low credits:', entitlements.creditsRemaining);
    }

    // Grant access to feature
    const result = await yourPremiumFeature();
    res.json({ result, creditsRemaining: entitlements.creditsRemaining });

  } catch (error) {
    if (error.response?.status === 403) {
      return res.status(403).json({
        error: 'Subscription expired or access revoked',
        action: 'redirect_to_1sub'
      });
    }
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});
```

```python Flask + Python
@app.route('/api/premium-feature', methods=['POST'])
def premium_feature():
    verification_token = session.get('verification_token')

    if not verification_token:
        return jsonify({'error': 'Not authenticated'}), 401

    try:
        # Verify token and get current entitlements
        response = requests.post(
            'https://1sub.io/api/v1/verify',
            json={'verificationToken': verification_token},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        data = response.json()

        if not data['valid']:
            return jsonify({'error': 'Access denied'}), 403

        # Update token if rotated
        if data.get('tokenRotated'):
            session['verification_token'] = data['verificationToken']
            db.users.update_token(
                session['onesub_user_id'],
                data['verificationToken']
            )

        # Grant access to feature
        result = your_premium_feature()
        return jsonify({
            'result': result,
            'creditsRemaining': data['entitlements']['creditsRemaining']
        })

    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 403:
            return jsonify({
                'error': 'Subscription expired or access revoked',
                'action': 'redirect_to_1sub'
            }), 403
        print(f'Verification failed: {e}')
        return jsonify({'error': 'Verification failed'}), 500
```
</CodeGroup>

<Tip>
Cache verification results for 5-15 minutes to reduce API calls. Update the cache when you receive webhook notifications.
</Tip>

## Step 4: Configure Webhooks

Receive real-time notifications when subscriptions change, avoiding the need for constant verification.

<Steps>
<Step title="Create webhook endpoint">
  Set up an endpoint to receive webhook events:

```typescript
import crypto from 'crypto';
import express from 'express';

app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['x-1sub-signature'] as string;
    const payload = req.body.toString();

    // Verify signature (see next step)
    if (!verifyWebhookSignature(payload, signature, process.env.ONESUB_WEBHOOK_SECRET!)) {
      return res.status(401).send('Invalid signature');
    }

    const event = JSON.parse(payload);

    // Process event
    handleWebhookEvent(event);

    res.json({ received: true });
  }
);
```

<Warning>
Use `express.raw()` middleware for webhook endpoints. You need the raw body to verify signatures.
</Warning>
</Step>

<Step title="Verify webhook signature">
  Validate that the webhook came from 1Sub:

```typescript
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

  if (!timestamp || !sig) return false;

  // Reject old timestamps (replay attack protection)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;

  // Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}
```
</Step>

<Step title="Handle webhook events">
  Process different event types:

```typescript
function handleWebhookEvent(event: any) {
  switch (event.type) {
    case 'entitlement.granted':
      console.log('New user authorized:', event.data.oneSubUserId);
      // User just authorized - they may already be in your system
      break;

    case 'entitlement.revoked':
      console.log('Access revoked:', event.data.oneSubUserId);
      // Terminate user sessions, revoke access
      invalidateUserSessions(event.data.oneSubUserId);
      break;

    case 'entitlement.changed':
      console.log('Subscription updated:', event.data.oneSubUserId);
      // Update cached entitlements
      updateUserEntitlements(event.data.oneSubUserId, event.data);
      break;

    case 'credits.consumed':
      console.log('Credits consumed:', event.data);
      // Update UI credit display
      break;

    case 'user.credit_low':
      console.log('User credits low:', event.data.oneSubUserId);
      // Send notification to user
      break;
  }
}
```
</Step>

<Step title="Configure webhook URL in dashboard">
  Set your webhook URL in the 1Sub vendor dashboard:

```
https://yourtool.com/webhooks/1sub
```

<Tip>
Use ngrok for local testing: `ngrok http 3000` then configure `https://abc123.ngrok.io/webhooks/1sub`
</Tip>
</Step>
</Steps>

## Step 5: Consume Credits (Optional)

If your tool uses a credit-based model, deduct credits when users consume resources:

```typescript
async function consumeCredits(onesubUserId: string, amount: number, reason: string) {
  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/credits/consume',
      {
        user_id: onesubUserId,
        amount: amount,
        reason: reason,
        idempotency_key: `${onesubUserId}-${Date.now()}-${reason}`
      },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    console.log(`Consumed ${amount} credits. New balance: ${response.data.new_balance}`);
    return response.data;

  } catch (error) {
    if (error.response?.status === 402) {
      throw new Error('Insufficient credits');
    }
    throw error;
  }
}

// Usage
app.post('/api/generate-image', async (req, res) => {
  const onesubUserId = req.session.onesubUserId;

  try {
    // Consume credits first
    await consumeCredits(onesubUserId, 10, 'Generated AI image (1024x1024)');

    // Generate image
    const image = await generateImage(req.body.prompt);

    res.json({ image });
  } catch (error) {
    if (error.message === 'Insufficient credits') {
      return res.status(402).json({ error: 'Insufficient credits' });
    }
    res.status(500).json({ error: 'Generation failed' });
  }
});
```

## Complete Example

Here's a complete working example combining all steps:

<CodeGroup>
```typescript Express + TypeScript
import express from 'express';
import session from 'express-session';
import axios from 'axios';
import crypto from 'crypto';

const app = express();
app.use(express.json());
app.use(session({ secret: process.env.SESSION_SECRET!, resave: false, saveUninitialized: false }));

const ONESUB_API_KEY = process.env.ONESUB_API_KEY!;
const ONESUB_WEBHOOK_SECRET = process.env.ONESUB_WEBHOOK_SECRET!;

// Step 1: Authorization callback
app.get('/auth/1sub/callback', async (req, res) => {
  const { code } = req.query;

  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/authorize/exchange',
      {
        code: code as string,
        redirectUri: 'https://yourtool.com/auth/1sub/callback'
      },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const { verificationToken, onesubUserId, grantId } = response.data;

    req.session.verificationToken = verificationToken;
    req.session.onesubUserId = onesubUserId;

    await db.users.upsert({ onesubUserId, verificationToken, grantId });

    res.redirect('/dashboard');
  } catch (error) {
    console.error('Authorization failed:', error);
    res.status(500).send('Authorization failed');
  }
});

// Step 2: Verify access
app.post('/api/premium-feature', async (req, res) => {
  const verificationToken = req.session.verificationToken;

  if (!verificationToken) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/verify',
      { verificationToken },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    if (!response.data.valid) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Update token if rotated
    if (response.data.tokenRotated) {
      req.session.verificationToken = response.data.verificationToken;
    }

    const result = await yourPremiumFeature();
    res.json({ result });

  } catch (error) {
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});

// Step 3: Webhook handler
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['x-1sub-signature'] as string;
    const payload = req.body.toString();

    if (!verifyWebhookSignature(payload, signature, ONESUB_WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }

    const event = JSON.parse(payload);

    switch (event.type) {
      case 'entitlement.revoked':
        invalidateUserSessions(event.data.oneSubUserId);
        break;
      case 'entitlement.changed':
        updateUserEntitlements(event.data.oneSubUserId, event.data);
        break;
    }

    res.json({ received: true });
  }
);

function verifyWebhookSignature(payload: string, signature: string, secret: string): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

  if (!timestamp || !sig) return false;

  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;

  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto.createHmac('sha256', secret).update(signedPayload).digest('hex');

  return crypto.timingSafeEqual(Buffer.from(expected), Buffer.from(sig));
}

app.listen(3000);
```

```python Flask + Python
from flask import Flask, request, session, redirect, jsonify
import requests
import os
import hmac
import hashlib
import time

app = Flask(__name__)
app.secret_key = os.environ['SECRET_KEY']

ONESUB_API_KEY = os.environ['ONESUB_API_KEY']
ONESUB_WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']

# Step 1: Authorization callback
@app.route('/auth/1sub/callback')
def callback():
    code = request.args.get('code')

    try:
        response = requests.post(
            'https://1sub.io/api/v1/authorize/exchange',
            json={
                'code': code,
                'redirectUri': 'https://yourtool.com/auth/1sub/callback'
            },
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        data = response.json()

        session['verification_token'] = data['verificationToken']
        session['onesub_user_id'] = data['onesubUserId']

        db.users.upsert({
            'onesub_user_id': data['onesubUserId'],
            'verification_token': data['verificationToken'],
            'grant_id': data['grantId']
        })

        return redirect('/dashboard')

    except requests.exceptions.HTTPError as e:
        print(f'Authorization failed: {e}')
        return 'Authorization failed', 500

# Step 2: Verify access
@app.route('/api/premium-feature', methods=['POST'])
def premium_feature():
    verification_token = session.get('verification_token')

    if not verification_token:
        return jsonify({'error': 'Not authenticated'}), 401

    try:
        response = requests.post(
            'https://1sub.io/api/v1/verify',
            json={'verificationToken': verification_token},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        data = response.json()

        if not data['valid']:
            return jsonify({'error': 'Access denied'}), 403

        if data.get('tokenRotated'):
            session['verification_token'] = data['verificationToken']

        result = your_premium_feature()
        return jsonify({'result': result})

    except requests.exceptions.HTTPError as e:
        print(f'Verification failed: {e}')
        return jsonify({'error': 'Verification failed'}), 500

# Step 3: Webhook handler
@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('X-1Sub-Signature')
    payload = request.get_data(as_text=True)

    if not verify_webhook_signature(payload, signature, ONESUB_WEBHOOK_SECRET):
        return 'Invalid signature', 401

    event = request.get_json()

    if event['type'] == 'entitlement.revoked':
        invalidate_user_sessions(event['data']['oneSubUserId'])
    elif event['type'] == 'entitlement.changed':
        update_user_entitlements(event['data']['oneSubUserId'], event['data'])

    return jsonify({'received': True})

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')

    if not timestamp or not sig:
        return False

    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False

    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(expected, sig)

if __name__ == '__main__':
    app.run(port=3000)
```
</CodeGroup>

## Test Your Integration

<AccordionGroup>
<Accordion title="Test Authorization Flow">
  1. Subscribe to your tool on 1Sub (use test mode)
  2. Click "Launch Tool"
  3. Verify you're redirected with an authorization code
  4. Verify the exchange succeeds and you're logged in
  5. Check that the verification token is stored
</Accordion>

<Accordion title="Test Verification">
  1. Call your protected endpoint
  2. Verify it grants access with a valid token
  3. Try with an invalid token (should return 403)
  4. Verify token rotation happens when needed
</Accordion>

<Accordion title="Test Webhooks">
  1. Use ngrok for local testing
  2. Configure webhook URL in dashboard
  3. Trigger events by subscribing/canceling
  4. Verify signature validation works
  5. Check that events are processed correctly
  6. Test with invalid signatures (should return 401)
</Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
<Card title="Understand Core Concepts" icon="book" href="/docs/concepts/authentication">
  Deep dive into the authorization flow and verification
</Card>

<Card title="Explore API Reference" icon="code" href="/docs/api/reference">
  Complete documentation of all API endpoints
</Card>

<Card title="Configure Webhooks" icon="webhook" href="/docs/webhooks/overview">
  Learn about webhook events and best practices
</Card>

<Card title="View More Examples" icon="file-code" href="/docs/examples/node">
  Browse complete examples in multiple languages
</Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
<Accordion title="Authorization Code Invalid or Expired">
  **Possible causes:**
  - Code has expired (60 second lifetime)
  - Code was already used (single-use)
  - Code was entered incorrectly

  **Solution:** Authorization codes are single-use and expire after 60 seconds. The user needs to click "Launch Tool" again to generate a new code.
</Accordion>

<Accordion title="Verification Token Invalid">
  **Possible causes:**
  - Token has expired (30 day lifetime)
  - User's access was revoked
  - Wrong tool ID

  **Solution:** Check that you're using the correct API key. If the token expired, the user needs to re-authorize by clicking "Launch Tool" again.
</Accordion>

<Accordion title="Webhook Signature Invalid">
  **Possible causes:**
  - Using parsed body instead of raw body
  - Wrong webhook secret
  - Timestamp too old (>5 minutes)

  **Solution:** Use `express.raw()` middleware and verify your webhook secret is correct in environment variables. The signature header is `X-1Sub-Signature` (note the capital X).
</Accordion>

<Accordion title="Access Denied (403)">
  **Possible causes:**
  - User's subscription expired
  - User's access was explicitly revoked
  - User doesn't have an active subscription

  **Solution:** Check the error response for details. Redirect the user back to 1Sub to renew their subscription or re-authorize.
</Accordion>
</AccordionGroup>

<Warning>
Always store your API key and webhook secret securely in environment variables. Never commit them to version control.
</Warning>

---
title: "Python Example"
description: "Complete Python / Flask integration example"
---

# Python / Flask Example

Complete working example of a 1Sub integration using Python and Flask.

## Installation

```bash
pip install flask requests python-dotenv
```

## Environment Variables

```bash
# .env
ONESUB_API_KEY=sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
ONESUB_WEBHOOK_SECRET=whsec-xxxxxxxxxxxxxxxxxxxxxxxx
TOOL_ID=your-tool-uuid
```

## Complete Implementation

```python
import os
import hashlib
import hmac
import time
import requests
from flask import Flask, request, jsonify
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)

API_KEY = os.environ['ONESUB_API_KEY']
WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']
TOOL_ID = os.environ['TOOL_ID']
BASE_URL = 'https://1sub.io/api/v1'

# In-memory cache (use Redis in production)
subscription_cache = {}

def hash_email(email: str) -> str:
    """Hash email for 1Sub verification"""
    normalized = email.lower().strip()
    return hashlib.sha256(normalized.encode()).hexdigest()

def verify_subscription(onesub_user_id: str = None, email: str = None) -> dict:
    """Verify user subscription"""
    url = f'{BASE_URL}/tools/subscriptions/verify'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }

    # Prefer oneSubUserId for speed (10x faster)
    if onesub_user_id:
        body = {'oneSubUserId': onesub_user_id}
    elif email:
        body = {'emailSha256': hash_email(email)}
    else:
        raise ValueError('Either onesub_user_id or email required')

    response = requests.post(url, json=body, headers=headers)

    if response.status_code == 404:
        return None

    response.raise_for_status()
    data = response.json()

    # Cache oneSubUserId for future lookups
    if data.get('oneSubUserId'):
        subscription_cache[data['oneSubUserId']] = {
            'active': data['active'],
            'cached_at': time.time()
        }

    return data

def consume_credits(onesub_user_id: str, amount: int, reason: str, idempotency_key: str) -> dict:
    """Consume credits from user balance"""
    url = f'{BASE_URL}/credits/consume'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }
    body = {
        'user_id': onesub_user_id,
        'amount': amount,
        'reason': reason,
        'idempotency_key': idempotency_key
    }

    response = requests.post(url, json=body, headers=headers)
    response.raise_for_status()
    return response.json()

def exchange_link_code(code: str, tool_user_id: str) -> dict:
    """Exchange link code for oneSubUserId"""
    url = f'{BASE_URL}/tools/link/exchange-code'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }
    body = {
        'code': code.upper(),
        'toolUserId': tool_user_id
    }

    response = requests.post(url, json=body, headers=headers)

    if response.status_code == 404:
        raise ValueError('Invalid or expired link code')

    response.raise_for_status()
    return response.json()

def verify_webhook_signature(payload: str, signature: str) -> bool:
    """Verify webhook signature"""
    if not signature:
        return False

    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')

    if not timestamp or not sig:
        return False

    # Check timestamp (within 5 minutes)
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False

    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        WEBHOOK_SECRET.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()

    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

@app.route('/api/link', methods=['POST'])
def link_account():
    """Link user account via email or link code"""
    data = request.json

    # Option 1: Email-based linking (for SaaS tools)
    if 'email' in data:
        try:
            sub = verify_subscription(email=data['email'])
            if not sub:
                return jsonify({'error': 'No subscription found'}), 404

            # Store oneSubUserId in your database
            # db.users.update(user_id, onesub_user_id=sub['oneSubUserId'])

            return jsonify({
                'linked': True,
                'oneSubUserId': sub['oneSubUserId'],
                'active': sub['active']
            })
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    # Option 2: Link code (for CLI/desktop apps)
    elif 'code' in data:
        try:
            link = exchange_link_code(data['code'], data['toolUserId'])

            # Store oneSubUserId in your database
            # db.users.update(tool_user_id, onesub_user_id=link['oneSubUserId'])

            return jsonify(link)
        except ValueError as e:
            return jsonify({'error': str(e)}), 404
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    return jsonify({'error': 'email or code required'}), 400

@app.route('/api/check-access', methods=['POST'])
def check_access():
    """Check if user has active subscription"""
    data = request.json
    onesub_user_id = data.get('oneSubUserId')

    if not onesub_user_id:
        return jsonify({'error': 'oneSubUserId required'}), 400

    # Check cache first (optional)
    cached = subscription_cache.get(onesub_user_id)
    if cached and time.time() - cached['cached_at'] < 300:  # 5 min cache
        return jsonify({'active': cached['active']})

    # Verify with 1Sub
    try:
        sub = verify_subscription(onesub_user_id=onesub_user_id)
        if not sub:
            return jsonify({'error': 'Subscription not found'}), 404

        return jsonify({'active': sub['active'], 'status': sub['status']})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/use-feature', methods=['POST'])
def use_feature():
    """Use a feature that consumes credits"""
    data = request.json
    onesub_user_id = data.get('oneSubUserId')

    if not onesub_user_id:
        return jsonify({'error': 'oneSubUserId required'}), 400

    try:
        # Consume credits
        result = consume_credits(
            onesub_user_id=onesub_user_id,
            amount=10,
            reason='Generated AI image',
            idempotency_key=f"img-{onesub_user_id}-{int(time.time())}"
        )

        return jsonify({
            'success': True,
            'credits_remaining': result['new_balance']
        })
    except requests.HTTPError as e:
        if e.response.status_code == 400:
            error_data = e.response.json()
            return jsonify({
                'error': 'Insufficient credits',
                'shortfall': error_data.get('shortfall')
            }), 400
        return jsonify({'error': str(e)}), 500

@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    """Handle 1Sub webhooks"""
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)

    # Verify signature
    if not verify_webhook_signature(payload, signature):
        return 'Invalid signature', 401

    event = request.get_json()
    event_type = event['type']

    # Process event
    if event_type == 'subscription.activated':
        # Update user status in database
        print(f"Subscription activated: {event['data']['oneSubUserId']}")
        pass

    elif event_type == 'subscription.canceled':
        # Revoke access
        print(f"Subscription canceled: {event['data']['oneSubUserId']}")
        pass

    elif event_type == 'subscription.updated':
        # Update subscription details
        print(f"Subscription updated: {event['data']['oneSubUserId']}")
        pass

    return jsonify({'received': True})

if __name__ == '__main__':
    app.run(debug=True)
```

## Key Concepts

### 1. Email-Based Linking (SaaS Tools)

For web applications where users have verified emails:

```python
# User logs in with email they used on 1Sub
user_email = "user@example.com"
subscription = verify_subscription(email=user_email)

if subscription:
    # Cache oneSubUserId for future lookups
    db.users.update(user_id, onesub_user_id=subscription['oneSubUserId'])
```

### 2. Link Code (CLI/Desktop Apps)

For applications where email linking isn't suitable:

```python
# User enters 6-character code from 1Sub
link_code = "AB12CD"
link_result = exchange_link_code(code=link_code, tool_user_id="internal-user-123")

# Store oneSubUserId
db.users.update(tool_user_id, onesub_user_id=link_result['oneSubUserId'])
```

### 3. Webhook Security

Always verify webhook signatures to prevent spoofing:

```python
# Use raw request body (not parsed JSON)
payload = request.get_data(as_text=True)
signature = request.headers.get('1sub-signature')

if not verify_webhook_signature(payload, signature):
    return 'Invalid signature', 401
```

## Production Checklist

- ✅ Use Redis for subscription caching instead of in-memory dict
- ✅ Implement proper error handling and logging
- ✅ Set up async webhook processing (Celery, RQ, etc.)
- ✅ Add retry logic for API calls with exponential backoff
- ✅ Monitor rate limits (100 req/min for verify, 30 req/min for email lookups)
- ✅ Store oneSubUserId in your database after first lookup
- ✅ Use environment variables for all secrets
- ✅ Enable HTTPS for webhook endpoints

## Additional Resources

- [API Reference](/api/reference) - Full endpoint documentation
- [Webhook Events](/webhooks/events) - All event types
- [Webhook Security](/webhooks/security-and-signing) - Signature verification details
- [Authentication Guide](/concepts/authentication) - Email vs link code flows





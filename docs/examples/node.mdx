---
title: "Node.js Example"
description: "Complete Node.js / Express integration example"
---

# Node.js / Express Example

Complete working example of a 1Sub integration using Node.js and Express.

## Installation

```bash
npm install express axios dotenv
```

## Environment Variables

```bash
# .env
ONESUB_API_KEY=sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
ONESUB_WEBHOOK_SECRET=whsec-xxxxxxxxxxxxxxxxxxxxxxxx
TOOL_ID=your-tool-uuid
PORT=3000
```

## Complete Implementation

```typescript
import express from 'express';
import axios from 'axios';
import crypto from 'crypto';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Configuration
const ONESUB_API_KEY = process.env.ONESUB_API_KEY;
const ONESUB_WEBHOOK_SECRET = process.env.ONESUB_WEBHOOK_SECRET;
const TOOL_ID = process.env.TOOL_ID;
const BASE_URL = 'https://1sub.io/api/v1';

// In-memory cache (use Redis in production)
const subscriptionCache = new Map();
const processedEvents = new Set();

// Middleware
app.use(express.json());

// ============================================================================
// 1. Account Linking
// ============================================================================

/**
 * Hash email for 1Sub verification
 */
function hashEmail(email: string): string {
  const normalized = email.toLowerCase().trim();
  return crypto.createHash('sha256').update(normalized).digest('hex');
}

/**
 * Verify subscription by oneSubUserId or email
 */
async function verifySubscription(
  oneSubUserId?: string,
  email?: string
): Promise<any> {
  const url = `${BASE_URL}/tools/subscriptions/verify`;
  const headers = {
    'Authorization': `Bearer ${ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  };

  // Prefer oneSubUserId for speed (10-20x faster)
  const body = oneSubUserId
    ? { oneSubUserId }
    : { emailSha256: hashEmail(email!) };

  try {
    const response = await axios.post(url, body, { headers });

    // Cache oneSubUserId for future lookups
    if (response.data.oneSubUserId) {
      subscriptionCache.set(response.data.oneSubUserId, {
        active: response.data.active,
        cachedAt: Date.now()
      });
    }

    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      return null;
    }
    throw error;
  }
}

/**
 * Exchange link code for oneSubUserId
 */
async function exchangeLinkCode(code: string, toolUserId: string): Promise<any> {
  const url = `${BASE_URL}/tools/link/exchange-code`;
  const headers = {
    'Authorization': `Bearer ${ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  };
  const body = {
    code: code.toUpperCase(),
    toolUserId
  };

  try {
    const response = await axios.post(url, body, { headers });
    return response.data;
  } catch (error: any) {
    if (error.response?.status === 404) {
      throw new Error('Invalid or expired link code');
    }
    throw error;
  }
}

/**
 * Consume credits from user balance
 */
async function consumeCredits(
  oneSubUserId: string,
  amount: number,
  reason: string,
  idempotencyKey: string
): Promise<any> {
  const url = `${BASE_URL}/credits/consume`;
  const headers = {
    'Authorization': `Bearer ${ONESUB_API_KEY}`,
    'Content-Type': 'application/json',
  };
  const body = {
    user_id: oneSubUserId,
    amount,
    reason,
    idempotency_key: idempotencyKey
  };

  const response = await axios.post(url, body, { headers });
  return response.data;
}

// ============================================================================
// 2. API Endpoints
// ============================================================================

/**
 * Link user account via email or link code
 */
app.post('/api/link', async (req, res) => {
  const { email, code, toolUserId } = req.body;

  try {
    // Option 1: Email-based linking (for SaaS tools)
    if (email) {
      const subscription = await verifySubscription(undefined, email);

      if (!subscription) {
        return res.status(404).json({ error: 'No subscription found for this email' });
      }

      // Store oneSubUserId in your database
      // await db.users.update(userId, { oneSubUserId: subscription.oneSubUserId });

      return res.json({
        linked: true,
        oneSubUserId: subscription.oneSubUserId,
        active: subscription.active
      });
    }

    // Option 2: Link code (for CLI/desktop apps)
    if (code && toolUserId) {
      const link = await exchangeLinkCode(code, toolUserId);

      // Store oneSubUserId in your database
      // await db.users.update(toolUserId, { oneSubUserId: link.oneSubUserId });

      return res.json(link);
    }

    return res.status(400).json({ error: 'email or (code + toolUserId) required' });
  } catch (error: any) {
    console.error('Link account error:', error);
    return res.status(500).json({ error: error.message });
  }
});

/**
 * Check if user has active subscription
 */
app.post('/api/check-access', async (req, res) => {
  const { oneSubUserId } = req.body;

  if (!oneSubUserId) {
    return res.status(400).json({ error: 'oneSubUserId required' });
  }

  try {
    // Check cache first (optional)
    const cached = subscriptionCache.get(oneSubUserId);
    if (cached && Date.now() - cached.cachedAt < 300000) { // 5 min cache
      return res.json({ active: cached.active });
    }

    // Verify with 1Sub
    const subscription = await verifySubscription(oneSubUserId);

    if (!subscription) {
      return res.status(404).json({ error: 'Subscription not found' });
    }

    return res.json({
      active: subscription.active,
      status: subscription.status
    });
  } catch (error: any) {
    console.error('Check access error:', error);
    return res.status(500).json({ error: error.message });
  }
});

/**
 * Protected endpoint - requires active subscription
 */
app.post('/api/premium-feature', async (req, res) => {
  const { oneSubUserId } = req.body;

  if (!oneSubUserId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const subscription = await verifySubscription(oneSubUserId);

    if (!subscription || !subscription.active) {
      return res.status(403).json({
        error: 'Active subscription required',
        status: subscription?.status || 'not_found'
      });
    }

    // Perform premium feature
    const result = { data: 'Premium content' };

    return res.json({
      success: true,
      result,
      subscription: {
        planId: subscription.planId,
        expiresAt: subscription.currentPeriodEnd
      }
    });
  } catch (error: any) {
    console.error('Premium feature error:', error);
    return res.status(500).json({ error: error.message });
  }
});

/**
 * Credit-based feature - consumes credits
 */
app.post('/api/use-feature', async (req, res) => {
  const { oneSubUserId } = req.body;

  if (!oneSubUserId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    // Consume credits
    const result = await consumeCredits(
      oneSubUserId,
      10,
      'Generated AI image',
      `img-${oneSubUserId}-${Date.now()}`
    );

    return res.json({
      success: true,
      credits_remaining: result.new_balance
    });
  } catch (error: any) {
    if (error.response?.status === 400) {
      const errorData = error.response.data;
      return res.status(400).json({
        error: 'Insufficient credits',
        shortfall: errorData.shortfall
      });
    }
    console.error('Use feature error:', error);
    return res.status(500).json({ error: error.message });
  }
});

// ============================================================================
// 3. Webhook Handler
// ============================================================================

/**
 * Verify webhook signature
 */
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

  if (!timestamp || !sig) return false;

  // Check timestamp (within 5 minutes)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;

  // Compute signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

/**
 * Webhook endpoint
 */
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }), // MUST use raw body
  (req, res) => {
    const signature = req.headers['x-1sub-signature'] as string;
    const payload = req.body.toString();

    // Verify signature
    if (!verifyWebhookSignature(payload, signature, ONESUB_WEBHOOK_SECRET!)) {
      console.error('Invalid webhook signature');
      return res.status(401).send('Invalid signature');
    }

    // Parse event
    const event = JSON.parse(payload);

    // Deduplicate
    if (processedEvents.has(event.id)) {
      console.log(`Event ${event.id} already processed`);
      return res.json({ received: true });
    }
    processedEvents.add(event.id);

    // Acknowledge receipt immediately
    res.json({ received: true });

    // Process asynchronously
    processWebhookAsync(event).catch(console.error);
  }
);

/**
 * Process webhook events asynchronously
 */
async function processWebhookAsync(event: any) {
  const { oneSubUserId } = event.data;

  switch (event.type) {
    case 'subscription.activated':
      console.log('Subscription activated:', oneSubUserId);
      // Invalidate cache
      subscriptionCache.delete(oneSubUserId);
      // Grant access and send welcome email
      break;

    case 'subscription.canceled':
      console.log('Subscription canceled:', oneSubUserId);
      // Invalidate cache
      subscriptionCache.delete(oneSubUserId);
      // Revoke access
      break;

    case 'subscription.updated':
      console.log('Subscription updated:', oneSubUserId);
      // Invalidate cache
      subscriptionCache.delete(oneSubUserId);
      // Update plan if changed
      if (event.data.previousPlanId !== event.data.planId) {
        // await updateUserPlan(oneSubUserId, event.data.planId);
      }
      break;

    case 'purchase.completed':
      console.log('Purchase completed:', oneSubUserId);
      // Log purchase
      break;

    case 'user.credit_low':
      console.log('User credits low:', oneSubUserId);
      // Send low credit warning
      break;

    case 'user.credit_depleted':
      console.log('User credits depleted:', oneSubUserId);
      // Suspend credit features
      break;

    case 'tool.status_changed':
      console.log('Tool status changed');
      // Handle tool suspension/reactivation
      break;

    default:
      console.log('Unknown event type:', event.type);
  }
}

// ============================================================================
// Start Server
// ============================================================================

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Webhook endpoint: http://localhost:${PORT}/webhooks/1sub`);
});
```

## Key Concepts

### 1. Email-Based Linking (SaaS Tools)

For web applications where users have verified emails:

```typescript
// User logs in with email they used on 1Sub
const userEmail = "user@example.com";
const subscription = await verifySubscription(undefined, userEmail);

if (subscription) {
  // Cache oneSubUserId for future lookups (10-20x faster)
  await db.users.update(userId, {
    oneSubUserId: subscription.oneSubUserId
  });
}
```

### 2. Link Code (CLI/Desktop Apps)

For applications where email linking isn't suitable:

```typescript
// User enters 6-character code from 1Sub
const linkCode = "AB12CD";
const toolUserId = "internal-user-123";

const link = await exchangeLinkCode(linkCode, toolUserId);

// Store oneSubUserId
await db.users.update(toolUserId, {
  oneSubUserId: link.oneSubUserId
});
```

### 3. Caching for Performance

Always cache subscription status to reduce API calls:

```typescript
const cached = subscriptionCache.get(oneSubUserId);
if (cached && Date.now() - cached.cachedAt < 300000) { // 5 min
  return cached.active;
}

// Otherwise, verify with 1Sub API
const subscription = await verifySubscription(oneSubUserId);
```

### 4. Webhook Security

Always verify webhook signatures to prevent spoofing:

```typescript
// MUST use raw body for signature verification
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['x-1sub-signature'];
    const payload = req.body.toString();

    if (!verifyWebhookSignature(payload, signature, WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }

    // Process event...
  }
);
```

## Production Checklist

- ✅ Use Redis for subscription caching instead of in-memory Map
- ✅ Implement proper error handling and logging
- ✅ Set up async webhook processing (Bull, BullMQ, etc.)
- ✅ Add retry logic for API calls with exponential backoff
- ✅ Monitor rate limits (100 req/min for verify, 30 req/min for email lookups)
- ✅ Store oneSubUserId in your database after first lookup
- ✅ Use environment variables for all secrets
- ✅ Enable HTTPS for webhook endpoints
- ✅ Implement webhook event deduplication (use Redis Set)
- ✅ Set up monitoring and alerts for failed webhooks

## Testing

```bash
# Test email-based linking
curl -X POST http://localhost:3000/api/link \
  -H 'Content-Type: application/json' \
  -d '{"email": "user@example.com"}'

# Test link code
curl -X POST http://localhost:3000/api/link \
  -H 'Content-Type: application/json' \
  -d '{"code": "AB12CD", "toolUserId": "user123"}'

# Test subscription check
curl -X POST http://localhost:3000/api/check-access \
  -H 'Content-Type: application/json' \
  -d '{"oneSubUserId": "550e8400-e29b-41d4-a716-446655440000"}'
```

## Additional Resources

- [Python Example](/examples/python) - Python/Flask implementation
- [cURL Examples](/examples/curl) - Quick API examples
- [API Reference](/api/reference) - Full endpoint documentation
- [Webhook Events](/webhooks/events) - All event types
- [Authentication Guide](/concepts/authentication) - Email vs link code flows

---
title: "Python Example"
description: "Complete Python / Flask integration example"
---

# Python / Flask Example

Complete working example of a 1Sub integration using Python and Flask with the Authorization Code Flow.

## Installation

```bash
pip install flask flask-session requests python-dotenv
```

## Environment Variables

```bash
# .env
ONESUB_API_KEY=sk-tool-xxxxxxxxxxxxxxxxxxxxxxxx
ONESUB_WEBHOOK_SECRET=whsec-xxxxxxxxxxxxxxxxxxxxxxxx
SESSION_SECRET=your-session-secret
CALLBACK_URL=https://yourapp.com/auth/1sub/callback
```

## Complete Implementation

```python
import os
import hmac
import hashlib
import time
import requests
from flask import Flask, request, jsonify, session, redirect
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)
app.secret_key = os.environ['SESSION_SECRET']

# Configuration
API_KEY = os.environ['ONESUB_API_KEY']
WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']
CALLBACK_URL = os.environ['CALLBACK_URL']
BASE_URL = 'https://1sub.io/api/v1'

# ============================================================================
# 1. Authorization Code Exchange
# ============================================================================

def exchange_auth_code(code: str) -> dict:
    """Exchange authorization code for verification token"""
    url = f'{BASE_URL}/authorize/exchange'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }
    body = {
        'code': code,
        'redirectUri': CALLBACK_URL
    }

    response = requests.post(url, json=body, headers=headers)
    response.raise_for_status()
    return response.json()

# ============================================================================
# 2. Token Verification
# ============================================================================

def verify_access(verification_token: str) -> dict:
    """
    Verify access token and get updated entitlements.
    IMPORTANT: Token rolls on each successful call - store the new token!
    """
    url = f'{BASE_URL}/verify'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }
    body = {'verificationToken': verification_token}

    response = requests.post(url, json=body, headers=headers)
    return response.json()

# ============================================================================
# 3. Credit Consumption
# ============================================================================

def consume_credits(onesub_user_id: str, amount: int, reason: str, idempotency_key: str) -> dict:
    """Consume credits from user balance"""
    url = f'{BASE_URL}/credits/consume'
    headers = {
        'Authorization': f'Bearer {API_KEY}',
        'Content-Type': 'application/json'
    }
    body = {
        'user_id': onesub_user_id,
        'amount': amount,
        'reason': reason,
        'idempotency_key': idempotency_key
    }

    response = requests.post(url, json=body, headers=headers)
    response.raise_for_status()
    return response.json()

# ============================================================================
# 4. Webhook Signature Verification
# ============================================================================

def verify_webhook_signature(payload: str, signature: str) -> bool:
    """Verify webhook signature"""
    if not signature:
        return False

    try:
        parts = dict(part.split('=') for part in signature.split(','))
        timestamp = parts.get('t')
        sig = parts.get('v1')

        if not timestamp or not sig:
            return False

        # Check timestamp (within 5 minutes)
        now = int(time.time())
        if abs(now - int(timestamp)) > 300:
            return False

        # Compute expected signature
        signed_payload = f"{timestamp}.{payload}"
        expected = hmac.new(
            WEBHOOK_SECRET.encode(),
            signed_payload.encode(),
            hashlib.sha256
        ).hexdigest()

        # Timing-safe comparison
        return hmac.compare_digest(expected, sig)
    except Exception:
        return False

# ============================================================================
# 5. Middleware
# ============================================================================

def require_subscription(f):
    """Decorator to require valid subscription"""
    from functools import wraps

    @wraps(f)
    def decorated_function(*args, **kwargs):
        verification_token = session.get('verification_token')
        next_verify_before = session.get('next_verify_before', 0)

        if not verification_token:
            return jsonify({'error': 'Not authenticated'}), 401

        # Check if verification is needed
        now = int(time.time())
        if now >= next_verify_before:
            try:
                result = verify_access(verification_token)

                if not result.get('valid'):
                    # Access revoked - clear session
                    session.clear()
                    return jsonify({
                        'error': 'Access revoked',
                        'reason': result.get('reason'),
                        'action': result.get('action')
                    }), 403

                # Update session with new token (tokens roll!)
                session['verification_token'] = result['verificationToken']
                session['entitlements'] = result['entitlements']
                session['next_verify_before'] = result['nextVerificationBefore']

            except Exception as e:
                print(f'Verification error: {e}')
                return jsonify({'error': 'Verification failed'}), 500

        return f(*args, **kwargs)

    return decorated_function

# ============================================================================
# 6. API Endpoints
# ============================================================================

@app.route('/auth/1sub/callback')
def auth_callback():
    """
    OAuth Callback Handler
    Users are redirected here from 1Sub with an authorization code
    """
    code = request.args.get('code')
    state = request.args.get('state')

    if not code:
        return redirect('/auth/error?reason=missing_code')

    # Optional: Validate state parameter for CSRF protection
    # if state != session.get('oauth_state'):
    #     return redirect('/auth/error?reason=invalid_state')

    try:
        result = exchange_auth_code(code)

        # Store in session
        session['onesub_user_id'] = result['onesubUserId']
        session['verification_token'] = result['verificationToken']
        session['entitlements'] = result['entitlements']
        session['next_verify_before'] = result['expiresAt']

        return redirect('/dashboard')

    except requests.HTTPError as e:
        print(f'Auth callback error: {e}')
        return redirect('/auth/error?reason=exchange_failed')


@app.route('/api/me')
@require_subscription
def get_me():
    """Get current user info and entitlements"""
    return jsonify({
        'onesubUserId': session.get('onesub_user_id'),
        'entitlements': session.get('entitlements')
    })


@app.route('/api/premium/feature', methods=['POST'])
@require_subscription
def premium_feature():
    """Protected premium feature endpoint"""
    # User has valid subscription - proceed with feature
    result = {'data': 'Premium content generated!'}

    return jsonify({
        'success': True,
        'result': result,
        'entitlements': session.get('entitlements')
    })


@app.route('/api/generate-image', methods=['POST'])
@require_subscription
def generate_image():
    """Credit-based feature endpoint"""
    onesub_user_id = session.get('onesub_user_id')

    try:
        # Consume credits
        result = consume_credits(
            onesub_user_id=onesub_user_id,
            amount=10,
            reason='Generated AI image',
            idempotency_key=f"img-{onesub_user_id}-{int(time.time())}"
        )

        # Update cached credits
        if 'entitlements' in session:
            session['entitlements']['creditsRemaining'] = result['new_balance']
            session.modified = True

        return jsonify({
            'success': True,
            'imageUrl': 'https://example.com/generated-image.png',
            'creditsRemaining': result['new_balance']
        })

    except requests.HTTPError as e:
        if e.response.status_code == 400:
            return jsonify({
                'error': 'Insufficient credits',
                'message': 'Please purchase more credits to continue'
            }), 400
        print(f'Generate image error: {e}')
        return jsonify({'error': str(e)}), 500


@app.route('/api/logout', methods=['POST'])
def logout():
    """Logout endpoint"""
    session.clear()
    return jsonify({'success': True})


# ============================================================================
# 7. Webhook Handler
# ============================================================================

@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    """
    Handle 1Sub webhooks
    Webhooks accelerate cache invalidation - not primary enforcement
    """
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)

    # Verify signature
    if not verify_webhook_signature(payload, signature):
        return 'Invalid signature', 401

    event = request.get_json()
    event_type = event['type']
    onesub_user_id = event['data'].get('oneSubUserId')

    # Process event
    if event_type == 'entitlement.granted':
        print(f"Entitlement granted: {onesub_user_id}")
        # User can now access your tool

    elif event_type == 'entitlement.revoked':
        print(f"Entitlement revoked: {onesub_user_id}")
        # Force re-verification on next request
        # In production: invalidate all sessions for this user

    elif event_type == 'entitlement.changed':
        print(f"Entitlement changed: {onesub_user_id}")
        # Plan upgraded/downgraded - reverify to get new limits

    elif event_type == 'verify.required':
        print(f"Verify required: {onesub_user_id}")
        # 1Sub is requesting immediate verification

    elif event_type == 'user.credit_low':
        print(f"User credits low: {onesub_user_id}")
        # Optional: notify user

    elif event_type == 'user.credit_depleted':
        print(f"User credits depleted: {onesub_user_id}")
        # Optional: notify user

    return jsonify({'received': True})


if __name__ == '__main__':
    app.run(debug=True, port=3000)
```

## Integration Flow

### 1. User Clicks "Launch Tool" on 1Sub

User is redirected to your callback URL:

```
https://yourapp.com/auth/1sub/callback?code=ac_xxxxx&state=csrf_token
```

### 2. Exchange Code for Token

```python
result = exchange_auth_code(code)

# Store in session
session['verification_token'] = result['verificationToken']
session['entitlements'] = result['entitlements']
```

### 3. Periodic Verification

The decorator automatically verifies every 5 minutes:

```python
@app.route('/api/feature', methods=['POST'])
@require_subscription
def feature():
    # User is verified - entitlements are fresh
    return jsonify({'entitlements': session.get('entitlements')})
```

### 4. Handle Revocation

When verification fails, clear the session:

```python
if not result.get('valid'):
    session.clear()
    return jsonify({
        'error': 'Access revoked',
        'action': result.get('action')  # 'terminate_session' or 'reauthenticate'
    }), 403
```

## Key Concepts

### Token Rolling

The verification token changes on every successful `/verify` call:

```python
result = verify_access(current_token)

if result.get('valid'):
    # CRITICAL: Store the new token!
    session['verification_token'] = result['verificationToken']
```

### Webhook Processing

Webhooks accelerate revocation but are not the primary enforcement:

```python
if event_type == 'entitlement.revoked':
    # Invalidate cached sessions for this user
    # Next request will fail verification
    pass
```

## Production Checklist

- ✅ Use Redis for session storage (Flask-Session with Redis)
- ✅ Implement proper error handling and logging
- ✅ Set up async webhook processing (Celery, RQ, etc.)
- ✅ Add retry logic for API calls with exponential backoff
- ✅ Monitor rate limits (100 req/min for verify, 30 req/min for exchange)
- ✅ Use environment variables for all secrets
- ✅ Enable HTTPS for all endpoints
- ✅ Implement webhook event deduplication
- ✅ Set up monitoring and alerts

## Redis Session Configuration

For production, use Redis for session storage:

```python
from flask_session import Session
import redis

app.config['SESSION_TYPE'] = 'redis'
app.config['SESSION_REDIS'] = redis.from_url('redis://localhost:6379')
app.config['SESSION_PERMANENT'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = 3600  # 1 hour

Session(app)
```

## Testing

```bash
# Test authorization flow
# 1. Visit your 1Sub tool page and click "Launch Tool"
# 2. You'll be redirected to your callback

# Test verification
curl -X GET http://localhost:3000/api/me \
  -H 'Cookie: session=YOUR_SESSION_COOKIE'

# Test protected endpoint
curl -X POST http://localhost:3000/api/premium/feature \
  -H 'Cookie: session=YOUR_SESSION_COOKIE' \
  -H 'Content-Type: application/json'

# Test credit consumption
curl -X POST http://localhost:3000/api/generate-image \
  -H 'Cookie: session=YOUR_SESSION_COOKIE' \
  -H 'Content-Type: application/json'
```

## Additional Resources

- [Node.js Example](/docs/examples/node) - Node.js/Express implementation
- [cURL Examples](/docs/examples/curl) - Quick API testing
- [API Reference](/docs/api/reference) - Full endpoint documentation
- [Webhook Events](/docs/webhooks/events) - All event types

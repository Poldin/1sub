---
title: "Webhooks Overview"
description: "Real-time notifications for subscription lifecycle events"
---

# Webhooks Overview

Webhooks allow 1Sub to notify your tool in real-time when subscription events occur. This enables you to react immediately to changes without polling the API.

## Why Use Webhooks?

<CardGroup cols={3}>
<Card title="Real-Time Updates" icon="bolt">
  Get notified instantly when subscriptions change, no polling required.
</Card>

<Card title="Reduce API Calls" icon="chart-line-down">
  Cache subscription status and update via webhooks instead of constant verification.
</Card>

<Card title="Better UX" icon="sparkles">
  Update user access immediately when they subscribe or cancel.
</Card>
</CardGroup>

## How Webhooks Work

<Steps>
<Step title="Configure webhook URL">
  Set your webhook endpoint in the 1Sub vendor dashboard:
  
```
https://yourtool.com/webhooks/1sub
```
</Step>

<Step title="Event occurs">
  User subscribes, cancels, or updates their subscription on 1Sub.
</Step>

<Step title="1Sub sends HTTP POST">
  We send a POST request to your webhook URL with event details:
  
```json
{
  "id": "evt_abc123",
  "type": "subscription.activated",
  "created": 1700000000,
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "planId": "monthly",
    "status": "active"
  }
}
```
</Step>

<Step title="You verify and process">
  Your endpoint verifies the signature and processes the event:
  
```typescript
// Verify signature
if (!verifySignature(payload, signature)) {
  return res.status(401).send('Invalid signature');
}

// Process event
const event = JSON.parse(payload);
handleSubscriptionEvent(event);

// Acknowledge receipt
res.json({ received: true });
```
</Step>

<Step title="Return 2xx response">
  Return any 2xx status code to acknowledge receipt. We'll retry if you don't.
</Step>
</Steps>

## Webhook Events

1Sub sends webhooks for subscription lifecycle, purchases, credit status, and system events:

### Subscription Lifecycle Events

<AccordionGroup>
<Accordion title="subscription.activated">
Sent when a new subscription is created or reactivated.

**When it's sent:**
- User completes initial subscription
- User reactivates a canceled subscription
- Free trial begins

**Use cases:**
- Grant user access
- Send welcome email
- Set up user resources
- Clear subscription cache

```json
{
  "type": "subscription.activated",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "planId": "pro",
    "status": "trialing",
    "currentPeriodEnd": "2025-12-01T00:00:00Z",
    "trialEndsAt": "2025-11-08T00:00:00Z"
  }
}
```
</Accordion>

<Accordion title="subscription.updated">
Sent when subscription details change.

**When it's sent:**
- User upgrades/downgrades plan
- Billing period renews
- Payment method updated
- Trial ends and converts to paid

**Use cases:**
- Update user's plan features
- Adjust usage limits
- Clear subscription cache
- Log plan changes

```json
{
  "type": "subscription.updated",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "planId": "enterprise",
    "status": "active",
    "previousPlanId": "pro",
    "currentPeriodEnd": "2025-12-01T00:00:00Z"
  }
}
```
</Accordion>

<Accordion title="subscription.canceled">
Sent when a subscription is canceled.

**When it's sent:**
- User cancels subscription
- Payment fails after retry period
- Subscription expires

**Use cases:**
- Revoke user access
- Send cancellation survey
- Archive user data
- Clear subscription cache

```json
{
  "type": "subscription.canceled",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "planId": "pro",
    "status": "canceled",
    "cancellationReason": "user_requested",
    "effectiveDate": "2025-12-01T00:00:00Z"
  }
}
```
</Accordion>
</AccordionGroup>

### Purchase Events

<AccordionGroup>
<Accordion title="purchase.completed">
Sent when a user completes a one-time purchase.

**When it's sent:**
- User completes one-time tool purchase
- User buys credit package
- Non-subscription payment confirmed

**Use cases:**
- Grant one-time access
- Log purchase for analytics
- Send purchase confirmation
- Update credit balance display

```json
{
  "type": "purchase.completed",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "checkoutId": "chk_abc123",
    "amount": 100,
    "purchaseType": "credits"
  }
}
```
</Accordion>
</AccordionGroup>

### Credit Notification Events

<AccordionGroup>
<Accordion title="user.credit_low">
Sent when a user's credits fall below the threshold (10 credits).

**When it's sent:**
- User's balance drops to 10 or fewer credits
- Only sent once when crossing threshold

**Use cases:**
- Send low credit warning
- Show in-app notification
- Prompt credit purchase
- Track credit usage patterns

```json
{
  "type": "user.credit_low",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "creditBalance": 8,
    "threshold": 10
  }
}
```
</Accordion>

<Accordion title="user.credit_depleted">
Sent when a user's credit balance reaches zero.

**When it's sent:**
- User's balance hits exactly 0
- User can no longer use credit-based features

**Use cases:**
- Suspend credit features
- Send urgent notification
- Show credit paywall
- Log credit depletion

```json
{
  "type": "user.credit_depleted",
  "data": {
    "oneSubUserId": "uuid-abc-123",
    "userEmail": "user@example.com",
    "creditBalance": 0
  }
}
```
</Accordion>
</AccordionGroup>

### System Events

<AccordionGroup>
<Accordion title="tool.status_changed">
Sent when your tool's status changes (system event).

**When it's sent:**
- Tool activated by admin
- Tool suspended/deactivated
- Maintenance mode changes

**Use cases:**
- Enter/exit maintenance mode
- Notify active users
- Alert operations team

```json
{
  "type": "tool.status_changed",
  "data": {
    "oneSubUserId": "system",
    "toolId": "tool-uuid",
    "toolStatus": false
  }
}
```
</Accordion>
</AccordionGroup>

## Webhook Payload Structure

All webhooks follow this structure:

<ResponseField name="id" type="string" required>
Unique event identifier (format: `evt_xxxxx`)
</ResponseField>

<ResponseField name="type" type="string" required>
Event type: `subscription.activated`, `subscription.updated`, or `subscription.canceled`
</ResponseField>

<ResponseField name="created" type="number" required>
Unix timestamp when the event was created
</ResponseField>

<ResponseField name="data" type="object" required>
Event-specific data about the subscription change

<Expandable title="Common Data Fields">
  <ResponseField name="oneSubUserId" type="string (UUID)" required>
  The 1Sub user ID
  </ResponseField>
  
  <ResponseField name="userEmail" type="string">
  The user's email address (included in all user-specific events)
  </ResponseField>
  
  <ResponseField name="planId" type="string" required>
  Plan identifier
  </ResponseField>
  
  <ResponseField name="status" type="string" required>
  Current subscription status
  </ResponseField>
  
  <ResponseField name="currentPeriodEnd" type="string (ISO 8601)">
  End of current billing period
  </ResponseField>
</Expandable>
</ResponseField>

## Security

Webhooks include an HMAC signature in the `1sub-signature` header to prove authenticity.

```http
1sub-signature: t=1700000000,v1=abcdef123456789...
```

**Always verify signatures before processing webhooks!**

<Warning>
Never process webhooks without signature verification. This prevents attackers from sending fake events.
</Warning>

See [Security and Signing](/webhooks/security-and-signing) for implementation details.

## Delivery Guarantees

<AccordionGroup>
<Accordion title="At-least-once delivery">
We guarantee each event will be delivered **at least once**. In rare cases (network issues, retries), you may receive duplicate events.

**Mitigation:** Use the event `id` to deduplicate:

```typescript
const processedEvents = new Set();

function handleWebhook(event: WebhookEvent) {
  if (processedEvents.has(event.id)) {
    console.log('Duplicate event, skipping');
    return;
  }
  
  processedEvents.add(event.id);
  processEvent(event);
}
```
</Accordion>

<Accordion title="Retry policy">
If your endpoint doesn't return a 2xx status, we'll retry:

- **Immediately** after first failure
- **After 5 minutes**
- **After 30 minutes**
- **After 2 hours**
- **After 6 hours**
- **After 24 hours**

After 7 attempts over 24 hours, we'll stop retrying that event.
</Accordion>

<Accordion title="Timeout">
Webhook requests timeout after 30 seconds. Respond quickly to avoid retries:

```typescript
app.post('/webhooks/1sub', async (req, res) => {
  // Verify signature synchronously
  if (!verifySignature(...)) {
    return res.status(401).send('Invalid signature');
  }
  
  // Acknowledge receipt immediately
  res.json({ received: true });
  
  // Process asynchronously (don't await)
  processWebhookAsync(req.body).catch(console.error);
});
```
</Accordion>

<Accordion title="Order not guaranteed">
Events may arrive out of order. Use the `created` timestamp to order events if needed:

```typescript
events.sort((a, b) => a.created - b.created);
```
</Accordion>
</AccordionGroup>

## Endpoint Requirements

Your webhook endpoint must:

- ✅ Be publicly accessible via HTTPS (HTTP not allowed)
- ✅ Respond within 30 seconds
- ✅ Return a 2xx status code to acknowledge receipt
- ✅ Verify webhook signatures
- ✅ Handle duplicate events gracefully (idempotent)
- ✅ Process events asynchronously if needed

<Note>
Use ngrok or a similar tool for local development. Your local endpoint needs to be publicly accessible for webhooks.
</Note>

## Best Practices

<AccordionGroup>
<Accordion title="Respond quickly">
Acknowledge receipt immediately, process asynchronously:

```typescript
app.post('/webhooks/1sub', async (req, res) => {
  // Quick validation
  if (!verifySignature(req.body, req.headers['1sub-signature'])) {
    return res.status(401).send('Invalid signature');
  }
  
  // Acknowledge immediately
  res.json({ received: true });
  
  // Queue for async processing
  await queue.add('process-webhook', {
    event: JSON.parse(req.body)
  });
});
```
</Accordion>

<Accordion title="Cache subscription status">
Update your subscription cache when webhooks arrive:

```typescript
const subscriptionCache = new Map();

function handleWebhook(event: WebhookEvent) {
  const { oneSubUserId, status } = event.data;
  
  if (event.type === 'subscription.canceled') {
    subscriptionCache.delete(oneSubUserId);
  } else {
    // Invalidate cache, will refetch on next check
    subscriptionCache.delete(oneSubUserId);
  }
}
```
</Accordion>

<Accordion title="Log all webhooks">
Keep an audit log of received webhooks:

```typescript
await db.webhooks.create({
  event_id: event.id,
  event_type: event.type,
  user_id: event.data.oneSubUserId,
  payload: event,
  received_at: new Date(),
});
```
</Accordion>

<Accordion title="Monitor webhook health">
Track webhook success/failure rates:

```typescript
const webhookMetrics = {
  received: 0,
  processed: 0,
  failed: 0,
};

function handleWebhook(event: WebhookEvent) {
  webhookMetrics.received++;
  
  try {
    processEvent(event);
    webhookMetrics.processed++;
  } catch (error) {
    webhookMetrics.failed++;
    console.error('Webhook processing failed:', error);
    throw error; // Will trigger retry
  }
}
```
</Accordion>
</AccordionGroup>

## Testing Webhooks

<Tabs>
<Tab title="Local Development">
Use ngrok to expose your local endpoint:

```bash
# Install ngrok
npm install -g ngrok

# Expose local port
ngrok http 3000

# Configure webhook URL in dashboard
https://abc123.ngrok.io/webhooks/1sub
```
</Tab>

<Tab title="Manual Testing">
Send test webhooks using curl:

```bash
# Generate signature first (see Security docs)
curl -X POST 'http://localhost:3000/webhooks/1sub' \
  -H '1sub-signature: t=1700000000,v1=abc123...' \
  -H 'Content-Type: application/json' \
  -d '{
    "id": "evt_test",
    "type": "subscription.activated",
    "created": 1700000000,
    "data": {
      "oneSubUserId": "test-user-123",
      "planId": "pro",
      "status": "active"
    }
  }'
```
</Tab>

<Tab title="Automated Testing">
Mock webhook delivery in tests:

```typescript
describe('Webhook Handler', () => {
  it('processes subscription.activated', async () => {
    const payload = {
      id: 'evt_test',
      type: 'subscription.activated',
      created: Date.now() / 1000,
      data: {
        oneSubUserId: 'test-user',
        planId: 'pro',
        status: 'active',
      },
    };
    
    const signature = generateSignature(JSON.stringify(payload));
    
    const response = await request(app)
      .post('/webhooks/1sub')
      .set('1sub-signature', signature)
      .send(payload);
    
    expect(response.status).toBe(200);
    expect(subscriptionCache.has('test-user')).toBe(false); // Invalidated
  });
});
```
</Tab>
</Tabs>

## Next Steps

<CardGroup cols={2}>
<Card title="View Event Details" icon="list" href="/docs/webhooks/events">
  Complete reference of all webhook event types and payloads
</Card>

<Card title="Implement Security" icon="shield" href="/docs/webhooks/security-and-signing">
  Learn how to verify webhook signatures
</Card>

<Card title="Test Webhooks" icon="flask" href="/docs/webhooks/testing">
  Set up local testing with ngrok and test events
</Card>

<Card title="See Examples" icon="code" href="/docs/examples/node">
  Complete webhook handler implementations
</Card>
</CardGroup>


---
title: "Webhook Security and Signing"
description: "How to verify webhook signatures and secure your webhook endpoint"
---

# Webhook Security and Signing

Learn how to verify webhook signatures to ensure webhooks are authentic and haven't been tampered with.

## Why Verify Signatures?

Without signature verification, anyone could send fake webhooks to your endpoint. Verification ensures:

- ✅ Webhooks are actually from 1Sub
- ✅ Payload hasn't been tampered with
- ✅ Request isn't a replay attack (timestamp check)

<Warning>
**Never process webhooks without signature verification.** This is a critical security requirement.
</Warning>

## Signature Format

Webhooks include an HMAC-SHA256 signature in the `x-1sub-signature` header:

```http
x-1sub-signature: t=1700000000,v1=abcdef123456789...
```

**Format breakdown:**
- `t=`: Unix timestamp when webhook was sent
- `v1=`: HMAC-SHA256 hex signature

## Verification Process

<Steps>
<Step title="Extract signature components">
Parse the `x-1sub-signature` header to get timestamp and signature:

```typescript
const signature = req.headers['x-1sub-signature'];
const parts = signature.split(',');
const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

if (!timestamp || !sig) {
  throw new Error('Invalid signature format');
}
```
</Step>

<Step title="Check timestamp freshness">
Reject old webhooks to prevent replay attacks:

```typescript
const now = Math.floor(Date.now() / 1000);
const age = Math.abs(now - parseInt(timestamp));

// Reject webhooks older than 5 minutes
if (age > 300) {
  throw new Error('Webhook timestamp too old');
}
```

<Note>
The 5-minute tolerance accounts for clock skew between servers.
</Note>
</Step>

<Step title="Get raw request body">
You must use the **raw request body** (not parsed JSON) for verification:

```typescript
// Express.js
app.post('/webhooks/1sub',
  express.raw({ type: 'application/json' }), // Get raw body
  (req, res) => {
    const payload = req.body.toString();
    // ...
  }
);
```

<Warning>
If you use parsed JSON, signature verification will fail. The signature is computed from the exact bytes received.
</Warning>
</Step>

<Step title="Compute expected signature">
Create HMAC-SHA256 of `timestamp.payload` using your webhook secret:

```typescript
import crypto from 'crypto';

const signedPayload = `${timestamp}.${payload}`;
const expected = crypto
  .createHmac('sha256', process.env.ONESUB_WEBHOOK_SECRET)
  .update(signedPayload)
  .digest('hex');
```
</Step>

<Step title="Compare signatures safely">
Use timing-safe comparison to prevent timing attacks:

```typescript
const isValid = crypto.timingSafeEqual(
  Buffer.from(expected),
  Buffer.from(sig)
);

if (!isValid) {
  throw new Error('Invalid signature');
}
```

<Tip>
Always use `crypto.timingSafeEqual()` or equivalent. Regular string comparison is vulnerable to timing attacks.
</Tip>
</Step>
</Steps>

## Complete Implementation

<Tabs>
<Tab title="Node.js / TypeScript">
```typescript
import crypto from 'crypto';
import express from 'express';

const WEBHOOK_SECRET = process.env.ONESUB_WEBHOOK_SECRET;

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  // Parse signature
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
  
  if (!timestamp || !sig) {
    console.error('Invalid signature format');
    return false;
  }
  
  // Check timestamp freshness (5 minute tolerance)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) {
    console.error('Webhook timestamp too old or in future');
    return false;
  }
  
  // Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  // Timing-safe comparison
  try {
    return crypto.timingSafeEqual(
      Buffer.from(expected),
      Buffer.from(sig)
    );
  } catch (error) {
    // timingSafeEqual throws if buffer lengths differ
    return false;
  }
}

// Webhook endpoint
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }), // CRITICAL: Get raw body
  (req, res) => {
    const signature = req.headers['x-1sub-signature'] as string;
    const payload = req.body.toString();
    
    // Verify signature
    if (!verifyWebhookSignature(payload, signature, WEBHOOK_SECRET)) {
      console.error('Webhook signature verification failed');
      return res.status(401).send('Invalid signature');
    }
    
    // Parse and process event
    const event = JSON.parse(payload);
    console.log('Valid webhook received:', event.type);
    
    // Process event...
    
    // Acknowledge receipt
    res.json({ received: true });
  }
);
```
</Tab>

<Tab title="Python / Flask">
```python
import hmac
import hashlib
import time
from flask import Flask, request, jsonify
import os

app = Flask(__name__)
WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']

def verify_webhook_signature(payload: str, signature: str, secret: str) -> bool:
    # Parse signature
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')
    
    if not timestamp or not sig:
        print('Invalid signature format')
        return False
    
    # Check timestamp freshness (5 minute tolerance)
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        print('Webhook timestamp too old or in future')
        return False
    
    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('x-1sub-signature')
    payload = request.get_data(as_text=True)  # Get raw body
    
    # Verify signature
    if not verify_webhook_signature(payload, signature, WEBHOOK_SECRET):
        print('Webhook signature verification failed')
        return 'Invalid signature', 401
    
    # Parse and process event
    event = request.get_json()
    print(f'Valid webhook received: {event["type"]}')
    
    # Process event...
    
    # Acknowledge receipt
    return jsonify({'received': True})
```
</Tab>

<Tab title="Go">
```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "crypto/subtle"
    "encoding/hex"
    "fmt"
    "io"
    "net/http"
    "os"
    "strconv"
    "strings"
    "time"
)

var webhookSecret = os.Getenv("ONESUB_WEBHOOK_SECRET")

func verifyWebhookSignature(payload []byte, signature, secret string) bool {
    // Parse signature
    parts := strings.Split(signature, ",")
    var timestamp, sig string
    for _, part := range parts {
        if strings.HasPrefix(part, "t=") {
            timestamp = strings.TrimPrefix(part, "t=")
        } else if strings.HasPrefix(part, "v1=") {
            sig = strings.TrimPrefix(part, "v1=")
        }
    }
    
    if timestamp == "" || sig == "" {
        fmt.Println("Invalid signature format")
        return false
    }
    
    // Check timestamp freshness (5 minute tolerance)
    ts, err := strconv.ParseInt(timestamp, 10, 64)
    if err != nil {
        return false
    }
    
    now := time.Now().Unix()
    if abs(now-ts) > 300 {
        fmt.Println("Webhook timestamp too old or in future")
        return false
    }
    
    // Compute expected signature
    signedPayload := fmt.Sprintf("%s.%s", timestamp, string(payload))
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write([]byte(signedPayload))
    expected := hex.EncodeToString(mac.Sum(nil))
    
    // Timing-safe comparison
    return subtle.ConstantTimeCompare(
        []byte(expected),
        []byte(sig),
    ) == 1
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    signature := r.Header.Get("x-1sub-signature")
    
    // Read raw body
    payload, err := io.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Error reading body", http.StatusBadRequest)
        return
    }
    
    // Verify signature
    if !verifyWebhookSignature(payload, signature, webhookSecret) {
        fmt.Println("Webhook signature verification failed")
        http.Error(w, "Invalid signature", http.StatusUnauthorized)
        return
    }
    
    fmt.Println("Valid webhook received")
    
    // Process event...
    
    // Acknowledge receipt
    w.Header().Set("Content-Type", "application/json")
    w.Write([]byte(`{"received": true}`))
}

func abs(n int64) int64 {
    if n < 0 {
        return -n
    }
    return n
}
```
</Tab>
</Tabs>

## Testing Signature Verification

### Generate Test Signatures

To test your verification logic, you can generate test signatures:

```typescript
function generateTestSignature(payload: string, secret: string): string {
  const timestamp = Math.floor(Date.now() / 1000);
  const signedPayload = `${timestamp}.${payload}`;
  const sig = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  return `t=${timestamp},v1=${sig}`;
}

// Usage
const testPayload = JSON.stringify({
  id: 'evt_test',
  type: 'subscription.activated',
  created: Date.now() / 1000,
  data: { /* ... */ }
});

const signature = generateTestSignature(testPayload, 'your-webhook-secret');

// Send test webhook
fetch('http://localhost:3000/webhooks/1sub', {
  method: 'POST',
  headers: {
    'x-1sub-signature': signature,
    'Content-Type': 'application/json',
  },
  body: testPayload,
});
```

### Unit Tests

```typescript
describe('Webhook Signature Verification', () => {
  const secret = 'test-secret-key';
  
  it('accepts valid signature', () => {
    const payload = '{"test":"data"}';
    const timestamp = Math.floor(Date.now() / 1000);
    const sig = crypto
      .createHmac('sha256', secret)
      .update(`${timestamp}.${payload}`)
      .digest('hex');
    const signature = `t=${timestamp},v1=${sig}`;
    
    const result = verifyWebhookSignature(payload, signature, secret);
    expect(result).toBe(true);
  });
  
  it('rejects tampered payload', () => {
    const payload = '{"test":"data"}';
    const timestamp = Math.floor(Date.now() / 1000);
    const sig = crypto
      .createHmac('sha256', secret)
      .update(`${timestamp}.${payload}`)
      .digest('hex');
    const signature = `t=${timestamp},v1=${sig}`;
    
    const tamperedPayload = '{"test":"tampered"}';
    const result = verifyWebhookSignature(tamperedPayload, signature, secret);
    expect(result).toBe(false);
  });
  
  it('rejects old timestamp', () => {
    const payload = '{"test":"data"}';
    const oldTimestamp = Math.floor(Date.now() / 1000) - 400; // 6+ minutes ago
    const sig = crypto
      .createHmac('sha256', secret)
      .update(`${oldTimestamp}.${payload}`)
      .digest('hex');
    const signature = `t=${oldTimestamp},v1=${sig}`;
    
    const result = verifyWebhookSignature(payload, signature, secret);
    expect(result).toBe(false);
  });
  
  it('rejects wrong secret', () => {
    const payload = '{"test":"data"}';
    const timestamp = Math.floor(Date.now() / 1000);
    const sig = crypto
      .createHmac('sha256', 'wrong-secret')
      .update(`${timestamp}.${payload}`)
      .digest('hex');
    const signature = `t=${timestamp},v1=${sig}`;
    
    const result = verifyWebhookSignature(payload, signature, secret);
    expect(result).toBe(false);
  });
});
```

## Common Pitfalls

<AccordionGroup>
<Accordion title="Using parsed JSON instead of raw body">
**Wrong:**
```typescript
app.post('/webhooks/1sub',
  express.json(), // Parses body
  (req, res) => {
    const payload = JSON.stringify(req.body); // Won't match!
    // Signature verification will fail
  }
);
```

**Correct:**
```typescript
app.post('/webhooks/1sub',
  express.raw({ type: 'application/json' }), // Raw body
  (req, res) => {
    const payload = req.body.toString(); // Exact bytes received
    // Signature verification will succeed
  }
);
```
</Accordion>

<Accordion title="Not using timing-safe comparison">
**Wrong:**
```typescript
// Vulnerable to timing attacks
if (expected === sig) { /* ... */ }
```

**Correct:**
```typescript
// Timing-safe
crypto.timingSafeEqual(Buffer.from(expected), Buffer.from(sig))
```
</Accordion>

<Accordion title="Not checking timestamp">
```typescript
// Wrong - vulnerable to replay attacks
const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];
return expected === sig;

// Correct - checks timestamp
const age = Math.abs(now - parseInt(timestamp));
if (age > 300) return false;
```
</Accordion>

<Accordion title="Hardcoding webhook secret">
**Wrong:**
```typescript
const secret = 'whsec_abc123'; // Hardcoded!
```

**Correct:**
```typescript
const secret = process.env.ONESUB_WEBHOOK_SECRET; // From env
```
</Accordion>
</AccordionGroup>

## Security Best Practices

<Check>
✅ **Always verify signatures** before processing webhooks
</Check>

<Check>
✅ **Use raw request body** for signature computation
</Check>

<Check>
✅ **Check timestamp** to prevent replay attacks
</Check>

<Check>
✅ **Use timing-safe comparison** to prevent timing attacks
</Check>

<Check>
✅ **Store webhook secret securely** in environment variables
</Check>

<Check>
✅ **Return 401** for invalid signatures (don't reveal why)
</Check>

<Check>
✅ **Log verification failures** for security monitoring
</Check>

<Warning>
If you detect repeated signature verification failures, it may indicate an attack or misconfiguration. Monitor your logs and alert on anomalies.
</Warning>













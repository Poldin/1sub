---
title: "Magic Login"
description: "Passwordless authentication for your users - zero API calls required"
---

# Magic Login

Magic Login enables seamless, passwordless authentication. When users click "Launch Magic Login" on 1Sub, they arrive at your app already signed in - no passwords, no friction.

<Info>
**Zero API calls required!** You verify the signature locally using your Magic Login Secret.
</Info>

---

## How It Works

```
┌─────────────────────────────────────────────────────────────────┐
│  1. User clicks "Launch Magic Login" on 1Sub                    │
│                    │                                            │
│                    ▼                                            │
│  2. 1Sub redirects to your Magic Login URL:                     │
│     https://yourapp.com/magic?user=xxx&ts=123&nonce=abc&sig=... │
│                    │                                            │
│                    ▼                                            │
│  3. Your server verifies signature (LOCAL - no API call!)       │
│                    │                                            │
│                    ▼                                            │
│  4. Look up user in your DB (you have data from webhooks)       │
│                    │                                            │
│                    ▼                                            │
│  5. Create session → User is in!                                │
└─────────────────────────────────────────────────────────────────┘
```

---

## Setup

### Step 1: Configure in Dashboard

In your [Vendor Dashboard](/vendor-dashboard/api):

1. Set your **Magic Login URL** (e.g., `https://yourapp.com/auth/magic`)
2. Generate a **Magic Login Secret** (click "Generate")
3. Save the configuration
4. Copy the secret to your server's environment variables

### Step 2: Handle Webhooks (Required)

Magic Login assumes you've already integrated webhooks to receive user data:

```typescript
// When user subscribes, you receive their data
app.post('/webhooks/1sub', (req, res) => {
  const event = req.body;

  if (event.type === 'subscription.activated') {
    // Store user data
    await db.users.create({
      oneSubUserId: event.data.oneSubUserId,
      email: event.data.userEmail,
      plan: event.data.planId,
      active: true
    });
  }

  if (event.type === 'subscription.canceled') {
    await db.users.update(event.data.oneSubUserId, { active: false });
  }

  // CRITICAL: Handle force logout for security
  if (event.type === 'security.force_logout') {
    // Immediately terminate all sessions for this user
    await sessionStore.deleteAllForUser(event.data.oneSubUserId);
  }

  res.status(200).send('OK');
});
```

### Step 3: Implement Magic Login Endpoint

```typescript
import crypto from 'crypto';

const MAGIC_LOGIN_SECRET = process.env.MAGIC_LOGIN_SECRET!;
const MAGIC_LOGIN_TTL_SECONDS = 300; // 5 minutes

// Track used nonces to prevent replay attacks
const usedNonces = new Map<string, number>();

// Cleanup old nonces periodically
setInterval(() => {
  const cutoff = Date.now() - (MAGIC_LOGIN_TTL_SECONDS + 60) * 1000;
  for (const [nonce, timestamp] of usedNonces.entries()) {
    if (timestamp < cutoff) usedNonces.delete(nonce);
  }
}, 60000);

app.get('/auth/magic', async (req, res) => {
  const { user, ts, nonce, sig } = req.query;

  // 1. Verify timestamp (link expires in 5 minutes)
  const now = Math.floor(Date.now() / 1000);
  const timestamp = parseInt(ts as string);

  if (now - timestamp > MAGIC_LOGIN_TTL_SECONDS) {
    return res.status(401).send('Link expired');
  }

  // 2. Check for future timestamps (clock skew attack)
  if (timestamp - now > 30) {
    return res.status(401).send('Invalid timestamp');
  }

  // 3. Check nonce hasn't been used (replay protection)
  if (usedNonces.has(nonce as string)) {
    return res.status(401).send('Link already used');
  }

  // 4. Verify signature using timing-safe comparison
  const expectedSig = crypto
    .createHmac('sha256', MAGIC_LOGIN_SECRET)
    .update(`${user}${ts}${nonce}`)
    .digest('hex');

  const sigBuffer = Buffer.from(sig as string);
  const expectedBuffer = Buffer.from(expectedSig);

  if (sigBuffer.length !== expectedBuffer.length ||
      !crypto.timingSafeEqual(sigBuffer, expectedBuffer)) {
    return res.status(401).send('Invalid signature');
  }

  // 5. Mark nonce as used
  usedNonces.set(nonce as string, Date.now());

  // 6. Look up user in YOUR database (populated via webhooks)
  const userData = await db.users.findByOneSubId(user as string);

  if (!userData || !userData.active) {
    return res.status(403).send('No active subscription');
  }

  // 7. Create session (recommended: max 24 hours)
  req.session.userId = user;
  req.session.email = userData.email;
  req.session.plan = userData.plan;
  req.session.expiresAt = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

  res.redirect('/dashboard');
});
```

---

## URL Parameters

When 1Sub redirects to your Magic Login URL, it includes these query parameters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `user` | string | The 1Sub User ID (`oneSubUserId`) |
| `ts` | number | Unix timestamp when the link was generated |
| `nonce` | string | Unique random value for replay protection |
| `sig` | string | HMAC-SHA256 signature for verification |

### Example URL

```
https://yourapp.com/auth/magic?user=550e8400-e29b-41d4-a716-446655440000&ts=1703001234&nonce=a1b2c3d4e5f6g7h8&sig=abc123...
```

---

## Signature Verification

The signature is generated using HMAC-SHA256:

```
signature = HMAC-SHA256(user + ts + nonce, magic_login_secret)
```

### Security Requirements

1. **Timestamp Validation**: Links expire after 5 minutes
2. **Nonce Tracking**: Each link can only be used once
3. **Timing-Safe Comparison**: Use `crypto.timingSafeEqual()` to prevent timing attacks
4. **Clock Skew**: Allow 30 seconds of clock drift

### Verification Examples

<CodeGroup>

```typescript Node.js
import crypto from 'crypto';

function verifyMagicLogin(user: string, ts: string, nonce: string, sig: string): boolean {
  const MAGIC_LOGIN_SECRET = process.env.MAGIC_LOGIN_SECRET!;
  const TTL_SECONDS = 300;

  // Check timestamp
  const now = Math.floor(Date.now() / 1000);
  const timestamp = parseInt(ts);
  if (now - timestamp > TTL_SECONDS || timestamp - now > 30) {
    return false;
  }

  // Verify signature
  const expected = crypto
    .createHmac('sha256', MAGIC_LOGIN_SECRET)
    .update(`${user}${ts}${nonce}`)
    .digest('hex');

  try {
    return crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(expected));
  } catch {
    return false;
  }
}
```

```python Python
import hmac
import hashlib
import time

def verify_magic_login(user: str, ts: str, nonce: str, sig: str) -> bool:
    MAGIC_LOGIN_SECRET = os.environ['MAGIC_LOGIN_SECRET']
    TTL_SECONDS = 300

    # Check timestamp
    now = int(time.time())
    timestamp = int(ts)
    if now - timestamp > TTL_SECONDS or timestamp - now > 30:
        return False

    # Verify signature
    data = f"{user}{ts}{nonce}"
    expected = hmac.new(
        MAGIC_LOGIN_SECRET.encode(),
        data.encode(),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(sig, expected)
```

```go Go
package auth

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "os"
    "strconv"
    "time"
)

func VerifyMagicLogin(user, ts, nonce, sig string) bool {
    secret := os.Getenv("MAGIC_LOGIN_SECRET")
    ttlSeconds := int64(300)

    // Check timestamp
    now := time.Now().Unix()
    timestamp, _ := strconv.ParseInt(ts, 10, 64)
    if now-timestamp > ttlSeconds || timestamp-now > 30 {
        return false
    }

    // Verify signature
    data := user + ts + nonce
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write([]byte(data))
    expected := hex.EncodeToString(mac.Sum(nil))

    return hmac.Equal([]byte(sig), []byte(expected))
}
```

</CodeGroup>

---

## Session Management

### Recommended Session Lifetime

We recommend **24 hours maximum** for sessions created via Magic Login:

```typescript
// Create session with expiry
req.session.expiresAt = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

// On each request, check session validity
if (req.session.expiresAt < Date.now()) {
  // Session expired, redirect to 1Sub for new Magic Login
  return res.redirect('https://1sub.dev/tools/your-tool-id');
}
```

### Handling Force Logout

1Sub can send a `security.force_logout` webhook when immediate session termination is required. You **MUST** handle this webhook:

```typescript
app.post('/webhooks/1sub', (req, res) => {
  const event = req.body;

  if (event.type === 'security.force_logout') {
    const { oneSubUserId, securityReason, affectedSessions } = event.data;

    // IMMEDIATELY terminate sessions
    await sessionStore.deleteAllForUser(oneSubUserId);

    // Log for audit
    console.log(`Force logout: user=${oneSubUserId}, reason=${securityReason}`);
  }

  res.status(200).send('OK');
});
```

### Force Logout Reasons

| Reason | Description |
|--------|-------------|
| `fraud_detected` | Suspicious activity detected |
| `admin_action` | Administrator manually triggered logout |
| `password_changed` | User changed their password |
| `account_compromised` | Account security breach detected |
| `user_request` | User requested logout from all devices |

---

## Webhook Events for Magic Login

When using Magic Login, you must handle these critical webhooks:

| Event | `require_reverification` | Action Required |
|-------|-------------------------|-----------------|
| `subscription.activated` | No | Create/update user in your DB |
| `subscription.canceled` | **Yes** | Mark user inactive, end sessions |
| `entitlement.revoked` | **Yes** | Remove access immediately |
| `security.force_logout` | **Yes** | Terminate ALL sessions immediately |

When `require_reverification: true` is set, you **MUST** either:
1. Terminate the user's sessions immediately, OR
2. Call `/api/v1/verify` within 5 minutes to check current status

---

## Security Best Practices

### DO:
- Use HTTPS for your Magic Login URL
- Implement nonce tracking to prevent replay attacks
- Use timing-safe comparison for signatures
- Set reasonable session lifetimes (max 24 hours)
- Handle `security.force_logout` webhooks
- Store the Magic Login secret securely (env vars, secrets manager)

### DON'T:
- Trust Magic Login URLs that are more than 5 minutes old
- Accept the same nonce twice
- Create indefinite sessions
- Ignore `require_reverification` webhooks
- Log the Magic Login secret

---

## Testing

You can test your Magic Login integration from the [Vendor Dashboard](/vendor-dashboard/api):

1. Configure your Magic Login URL and Secret
2. Click "Test Magic Login"
3. You'll be redirected to your Magic Login URL with test parameters
4. Verify your implementation handles the request correctly

<Warning>
Test mode bypasses subscription checks. In production, only users with active subscriptions can use Magic Login.
</Warning>

---

## Troubleshooting

### "Link expired"
- The Magic Login URL was generated more than 5 minutes ago
- User should click "Launch Magic Login" again

### "Link already used"
- The nonce has been used before (replay attack prevented)
- User should click "Launch Magic Login" again

### "Invalid signature"
- Magic Login secret mismatch between 1Sub and your server
- Check your `MAGIC_LOGIN_SECRET` environment variable
- Ensure you're using the correct signature format: `HMAC-SHA256(user + ts + nonce, secret)`

### "No active subscription"
- User's subscription has been canceled or is inactive
- Check your webhook handler for `subscription.canceled` events
- Verify your local user database is up to date

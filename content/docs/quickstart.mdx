---
title: "Quickstart Guide"
description: "Get your tool integrated with 1Sub in under 15 minutes"
---

# Quickstart Guide

This guide will walk you through integrating your tool with 1Sub in three simple steps. By the end, you'll have user account linking, subscription verification, and webhooks fully configured.

<Note>
**Prerequisites**: Make sure you have your API key and webhook secret from the 1Sub vendor dashboard. If you haven't received these yet, publish your tool first.
</Note>

## Choose Your Integration Method

1Sub supports two authentication methods. Choose based on your tool type:

<CardGroup cols={2}>
<Card title="Email-Based Verification" icon="envelope">
  **Best for:** Web apps, SaaS tools with email authentication

  Users link accounts using their verified email address. Seamless UX, no codes needed.
</Card>

<Card title="Link Codes" icon="key">
  **Best for:** CLI tools, desktop apps, mobile apps

  Users receive a 6-character code to enter in your tool. Works everywhere.
</Card>
</CardGroup>

## Installation

No special libraries required! Just your favorite HTTP client:

<CodeGroup>
```bash npm
npm install axios  # or any HTTP client
```

```bash yarn
yarn add axios
```

```bash pnpm
pnpm add axios
```
</CodeGroup>

## Step 1: Link User Accounts

Choose the method that works best for your tool:

<Tabs>
<Tab title="Email-Based (SaaS)">
### Email-Based Account Linking

When your tool already has authenticated users with verified emails, you can seamlessly link their 1Sub accounts.

<Steps>
<Step title="Hash the user's email">
  After user logs into your tool, hash their email with SHA256:

```typescript
import crypto from 'crypto';

function hashEmail(email: string): string {
  const normalized = email.toLowerCase().trim();
  return crypto.createHash('sha256').update(normalized).digest('hex');
}

// Example
const email = user.email; // From your auth system
const emailHash = hashEmail(email);
```
</Step>

<Step title="Verify subscription and get oneSubUserId">
  Call the verify endpoint with the email hash:

```typescript
async function linkUserAccount(email: string) {
  const emailHash = hashEmail(email);

  const response = await fetch('https://1sub.io/api/v1/tools/subscriptions/verify', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ emailSha256: emailHash })
  });

  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('No subscription found for this email');
    }
    throw new Error('Verification failed');
  }

  const data = await response.json();

  // Cache the oneSubUserId for future verifications
  await db.users.update(user.id, {
    oneSubUserId: data.oneSubUserId,
    subscriptionStatus: data.status,
    creditsRemaining: data.creditsRemaining
  });

  return data;
}
```

<Check>
The user is now linked! Store the `oneSubUserId` for future subscription checks.
</Check>
</Step>

<Step title="Use oneSubUserId for future verifications">
  For subsequent calls, use the cached `oneSubUserId` (10-20x faster):

```typescript
async function checkSubscription(oneSubUserId: string) {
  const response = await fetch('https://1sub.io/api/v1/tools/subscriptions/verify', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ oneSubUserId })
  });

  return await response.json();
}
```

<Tip>
Always cache `oneSubUserId` after the first email lookup. Email lookups are rate-limited to 30/min, while userId lookups allow 100/min.
</Tip>
</Step>
</Steps>

<Warning>
**Important:** Only use email-based verification if you've verified the user's email through your own authentication system (e.g., email confirmation during signup). Never accept unverified email addresses.
</Warning>
</Tab>

<Tab title="Link Codes (CLI/Desktop)">
### Link Code Account Linking

Users receive a 6-character code after subscribing that they enter in your tool.

<Steps>
<Step title="Display link code UI">
  After subscription, users receive a link code from 1Sub. Create a UI for them to enter it:

```typescript
app.post('/link-account', async (req, res) => {
  const { code, userId } = req.body;

  // Validate format (6-10 uppercase alphanumeric)
  const CODE_REGEX = /^[A-Z0-9]{6,10}$/;
  if (!CODE_REGEX.test(code)) {
    return res.status(400).json({ error: 'Invalid code format' });
  }

  // Continue to next step...
});
```
</Step>

<Step title="Exchange code for oneSubUserId">
  Call the exchange endpoint to link the accounts:

```typescript
async function exchangeLinkCode(code: string, toolUserId: string) {
  const response = await fetch('https://1sub.io/api/v1/tools/link/exchange-code', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      code: code.toUpperCase(),
      toolUserId: toolUserId
    })
  });

  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('Invalid or expired code');
    }
    throw new Error('Failed to exchange code');
  }

  const data = await response.json();

  // Store oneSubUserId for future verification
  await db.users.update(toolUserId, {
    oneSubUserId: data.oneSubUserId,
    linkedAt: data.linkedAt
  });

  return data; // { linked: true, oneSubUserId, toolUserId, linkedAt }
}
```

<Check>
The user account is now linked! Store the `oneSubUserId` for subscription verification.
</Check>
</Step>

<Step title="Handle expired codes gracefully">
  Link codes expire after 10 minutes. Provide clear error messages:

```typescript
try {
  const result = await exchangeLinkCode(code, userId);
  res.json({ success: true, message: 'Account linked successfully!' });
} catch (error) {
  if (error.message.includes('expired')) {
    res.status(400).json({
      error: 'Code expired',
      message: 'This code has expired. Please generate a new one from your 1Sub account settings.'
    });
  } else {
    res.status(400).json({
      error: 'Invalid code',
      message: 'The code you entered is invalid. Please check and try again.'
    });
  }
}
```
</Step>
</Steps>

<Note>
Link codes are **single-use** and expire after **10 minutes**. The exchange endpoint is idempotent - calling it multiple times with the same `toolUserId` returns the existing link.
</Note>
</Tab>
</Tabs>

## Step 2: Verify Subscriptions

Before granting access to premium features, verify that the user has an active subscription.

<Steps>
<Step title="Create a verification function">
  Set up a reusable function to check subscription status:

```typescript
import axios from 'axios';

async function verifySubscription(oneSubUserId: string) {
  const response = await axios.post(
    'https://1sub.io/api/v1/tools/subscriptions/verify',
    { oneSubUserId },
    {
      headers: {
        'Authorization': `Bearer ${process.env.ONESUB_API_KEY}`,
        'Content-Type': 'application/json',
      },
    }
  );

  return response.data;
}
```
</Step>

<Step title="Protect your premium endpoints">
  Add verification to your protected routes:

```typescript
app.post('/api/premium-feature', async (req, res) => {
  const userId = req.session.userId;

  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  // Get 1Sub user ID from your database
  const oneSubUserId = await getOneSubUserId(userId);

  if (!oneSubUserId) {
    return res.status(403).json({ error: 'Account not linked to 1Sub' });
  }

  try {
    const subscription = await verifySubscription(oneSubUserId);

    if (!subscription.active) {
      return res.status(403).json({
        error: 'Subscription required',
        status: subscription.status,
      });
    }

    // Grant access to feature
    const result = await yourPremiumFeature();
    res.json({ result });

  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(403).json({ error: 'No subscription found' });
    }
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});
```

<Check>
Your premium features are now protected by subscription verification.
</Check>
</Step>

<Step title="Cache subscription status (optional but recommended)">
  Reduce API calls by caching verification results:

```typescript
const cache = new Map();

async function getCachedSubscription(oneSubUserId: string) {
  if (cache.has(oneSubUserId)) {
    const cached = cache.get(oneSubUserId);
    if (Date.now() - cached.timestamp < 60000) { // 1 minute
      return cached.data;
    }
  }

  const data = await verifySubscription(oneSubUserId);
  cache.set(oneSubUserId, { data, timestamp: Date.now() });
  return data;
}
```

<Tip>
Update the cache when you receive webhook notifications to keep it fresh.
</Tip>
</Step>
</Steps>

## Step 3: Configure Webhooks

Receive real-time notifications when subscriptions change.

<Steps>
<Step title="Create webhook endpoint">
  Set up an endpoint to receive webhook events:

```typescript
import crypto from 'crypto';
import express from 'express';

app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();

    // Continue to next step...
  }
);
```

<Warning>
Use `express.raw()` middleware for webhook endpoints. You need the raw body to verify signatures.
</Warning>
</Step>

<Step title="Verify webhook signature">
  Validate that the webhook came from 1Sub:

```typescript
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

  if (!timestamp || !sig) return false;

  // Reject old timestamps (replay attack protection)
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;

  // Compute expected signature
  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

// In your webhook handler:
if (!verifyWebhookSignature(payload, signature, process.env.ONESUB_WEBHOOK_SECRET)) {
  return res.status(401).send('Invalid signature');
}
```

<Check>
Webhooks are now authenticated and protected from replay attacks.
</Check>
</Step>

<Step title="Handle webhook events">
  Process different event types:

```typescript
const event = JSON.parse(payload);

switch (event.type) {
  case 'subscription.activated':
    console.log('Subscription activated:', event.data.oneSubUserId);
    // Clear cache, send welcome email, etc.
    cache.delete(event.data.oneSubUserId);
    break;

  case 'subscription.canceled':
    console.log('Subscription canceled:', event.data.oneSubUserId);
    // Revoke access, send cancellation email, etc.
    cache.delete(event.data.oneSubUserId);
    break;

  case 'subscription.updated':
    console.log('Subscription updated:', event.data.oneSubUserId);
    // Update cached status
    cache.delete(event.data.oneSubUserId);
    break;
}

res.json({ received: true });
```
</Step>

<Step title="Configure webhook URL in dashboard">
  Set your webhook URL in the 1Sub vendor dashboard:

```
https://yourtool.com/webhooks/1sub
```

<Tip>
Make sure your webhook endpoint is publicly accessible via HTTPS. Use ngrok for local testing.
</Tip>
</Step>
</Steps>

## Test Your Integration

<AccordionGroup>
<Accordion title="Test Account Linking">
  **Email-Based:**
  1. Log into your tool with a verified email
  2. Verify the email hash lookup returns the correct subscription
  3. Check that oneSubUserId is cached in your database

  **Link Codes:**
  1. Subscribe to your tool on 1Sub (use test mode)
  2. Note the link code provided
  3. Enter code in your tool
  4. Verify the link is created in your database
</Accordion>

<Accordion title="Test Subscription Verification">
  1. Call your protected endpoint
  2. Verify it returns 403 for users without subscriptions
  3. Subscribe and verify it grants access
  4. Cancel subscription and verify access is revoked
</Accordion>

<Accordion title="Test Webhooks">
  1. Use a tool like RequestBin or ngrok for local testing
  2. Trigger events by creating/canceling subscriptions
  3. Verify signature validation works
  4. Check that events are processed correctly
  5. Test with invalid signatures (should return 401)
</Accordion>
</AccordionGroup>

## Complete Example

Here's a complete working example combining all three steps:

<CodeGroup>
```typescript Express + TypeScript
import express from 'express';
import axios from 'axios';
import crypto from 'crypto';

const app = express();
app.use(express.json());

const ONESUB_API_KEY = process.env.ONESUB_API_KEY;
const ONESUB_WEBHOOK_SECRET = process.env.ONESUB_WEBHOOK_SECRET;

// Helper: Hash email
function hashEmail(email: string): string {
  const normalized = email.toLowerCase().trim();
  return crypto.createHash('sha256').update(normalized).digest('hex');
}

// Step 1: Email-Based Account Linking
app.post('/link-account/email', async (req, res) => {
  const { userId } = req.session;

  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  try {
    const user = await db.users.findById(userId);
    const emailHash = hashEmail(user.email);

    const response = await axios.post(
      'https://1sub.io/api/v1/tools/subscriptions/verify',
      { emailSha256: emailHash },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    // Cache oneSubUserId
    await db.users.update(userId, {
      oneSubUserId: response.data.oneSubUserId,
      subscriptionStatus: response.data.status
    });

    res.json({ success: true, subscription: response.data });
  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(404).json({ error: 'No subscription found for this email' });
    }
    console.error('Link failed:', error);
    res.status(500).json({ error: 'Failed to link account' });
  }
});

// Step 1: Link Code Account Linking (Alternative)
app.post('/link-account/code', async (req, res) => {
  const { code, userId } = req.body;

  const CODE_REGEX = /^[A-Z0-9]{6,10}$/;
  if (!CODE_REGEX.test(code)) {
    return res.status(400).json({ error: 'Invalid code format' });
  }

  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/tools/link/exchange-code',
      { code: code.toUpperCase(), toolUserId: userId },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    await db.users.update(userId, {
      oneSubUserId: response.data.oneSubUserId,
      linkedAt: response.data.linkedAt
    });

    res.json({ success: true, linked: true });
  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(400).json({ error: 'Invalid or expired code' });
    }
    console.error('Exchange failed:', error);
    res.status(500).json({ error: 'Failed to exchange code' });
  }
});

// Step 2: Subscription Verification
app.post('/api/premium-feature', async (req, res) => {
  const { userId } = req.session;

  if (!userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }

  const user = await db.users.findById(userId);

  if (!user.oneSubUserId) {
    return res.status(403).json({ error: 'Account not linked' });
  }

  try {
    const response = await axios.post(
      'https://1sub.io/api/v1/tools/subscriptions/verify',
      { oneSubUserId: user.oneSubUserId },
      {
        headers: {
          'Authorization': `Bearer ${ONESUB_API_KEY}`,
          'Content-Type': 'application/json',
        },
      }
    );

    if (!response.data.active) {
      return res.status(403).json({
        error: 'Subscription required',
        status: response.data.status,
      });
    }

    const result = await yourPremiumFeature();
    res.json({ result });
  } catch (error) {
    if (error.response?.status === 404) {
      return res.status(403).json({ error: 'No subscription found' });
    }
    console.error('Verification failed:', error);
    res.status(500).json({ error: 'Verification failed' });
  }
});

// Step 3: Webhook Handler
app.post(
  '/webhooks/1sub',
  express.raw({ type: 'application/json' }),
  (req, res) => {
    const signature = req.headers['1sub-signature'] as string;
    const payload = req.body.toString();

    if (!verifyWebhookSignature(payload, signature, ONESUB_WEBHOOK_SECRET)) {
      return res.status(401).send('Invalid signature');
    }

    const event = JSON.parse(payload);

    switch (event.type) {
      case 'subscription.activated':
        console.log('Subscription activated:', event.data.oneSubUserId);
        break;
      case 'subscription.canceled':
        console.log('Subscription canceled:', event.data.oneSubUserId);
        break;
      case 'subscription.updated':
        console.log('Subscription updated:', event.data.oneSubUserId);
        break;
    }

    res.json({ received: true });
  }
);

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.split('=')[1];
  const sig = parts.find(p => p.startsWith('v1='))?.split('=')[1];

  if (!timestamp || !sig) return false;

  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - parseInt(timestamp)) > 300) return false;

  const signedPayload = `${timestamp}.${payload}`;
  const expected = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(expected),
    Buffer.from(sig)
  );
}

app.listen(3000);
```

```python Flask + Python
import os
import hmac
import hashlib
import time
import requests
from flask import Flask, request, session, jsonify

app = Flask(__name__)
app.secret_key = os.environ['SECRET_KEY']

ONESUB_API_KEY = os.environ['ONESUB_API_KEY']
ONESUB_WEBHOOK_SECRET = os.environ['ONESUB_WEBHOOK_SECRET']

# Helper: Hash email
def hash_email(email: str) -> str:
    normalized = email.lower().strip()
    return hashlib.sha256(normalized.encode()).hexdigest()

# Step 1: Email-Based Account Linking
@app.route('/link-account/email', methods=['POST'])
def link_account_email():
    user_id = session.get('user_id')

    if not user_id:
        return jsonify({'error': 'Not authenticated'}), 401

    try:
        user = db.users.find_by_id(user_id)
        email_hash = hash_email(user['email'])

        response = requests.post(
            'https://1sub.io/api/v1/tools/subscriptions/verify',
            json={'emailSha256': email_hash},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        data = response.json()

        # Cache oneSubUserId
        db.users.update(user_id, {
            'onesub_user_id': data['oneSubUserId'],
            'subscription_status': data['status']
        })

        return jsonify({'success': True, 'subscription': data})

    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return jsonify({'error': 'No subscription found'}), 404
        print(f'Link failed: {e}')
        return jsonify({'error': 'Failed to link account'}), 500

# Step 1: Link Code Account Linking (Alternative)
@app.route('/link-account/code', methods=['POST'])
def link_account_code():
    data = request.get_json()
    code = data.get('code')
    user_id = data.get('userId')

    import re
    if not re.match(r'^[A-Z0-9]{6,10}$', code):
        return jsonify({'error': 'Invalid code format'}), 400

    try:
        response = requests.post(
            'https://1sub.io/api/v1/tools/link/exchange-code',
            json={'code': code.upper(), 'toolUserId': user_id},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        result = response.json()

        db.users.update(user_id, {
            'onesub_user_id': result['oneSubUserId'],
            'linked_at': result['linkedAt']
        })

        return jsonify({'success': True, 'linked': True})

    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return jsonify({'error': 'Invalid or expired code'}), 400
        print(f'Exchange failed: {e}')
        return jsonify({'error': 'Failed to exchange code'}), 500

# Step 2: Subscription Verification
@app.route('/api/premium-feature', methods=['POST'])
def premium_feature():
    user_id = session.get('user_id')

    if not user_id:
        return jsonify({'error': 'Not authenticated'}), 401

    user = db.users.find_by_id(user_id)

    if not user.get('onesub_user_id'):
        return jsonify({'error': 'Account not linked'}), 403

    try:
        response = requests.post(
            'https://1sub.io/api/v1/tools/subscriptions/verify',
            json={'oneSubUserId': user['onesub_user_id']},
            headers={
                'Authorization': f'Bearer {ONESUB_API_KEY}',
                'Content-Type': 'application/json'
            }
        )
        response.raise_for_status()

        subscription = response.json()

        if not subscription['active']:
            return jsonify({
                'error': 'Subscription required',
                'status': subscription['status']
            }), 403

        result = your_premium_feature()
        return jsonify({'result': result})

    except requests.exceptions.HTTPError as e:
        if e.response.status_code == 404:
            return jsonify({'error': 'No subscription found'}), 403
        print(f'Verification failed: {e}')
        return jsonify({'error': 'Verification failed'}), 500

# Step 3: Webhook Handler
@app.route('/webhooks/1sub', methods=['POST'])
def webhook_handler():
    signature = request.headers.get('1sub-signature')
    payload = request.get_data(as_text=True)

    if not verify_webhook_signature(payload, signature, ONESUB_WEBHOOK_SECRET):
        return 'Invalid signature', 401

    event = request.get_json()

    if event['type'] == 'subscription.activated':
        print(f"Subscription activated: {event['data']['oneSubUserId']}")
    elif event['type'] == 'subscription.canceled':
        print(f"Subscription canceled: {event['data']['oneSubUserId']}")
    elif event['type'] == 'subscription.updated':
        print(f"Subscription updated: {event['data']['oneSubUserId']}")

    return jsonify({'received': True})

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts.get('t')
    sig = parts.get('v1')

    if not timestamp or not sig:
        return False

    # Check timestamp
    now = int(time.time())
    if abs(now - int(timestamp)) > 300:
        return False

    # Compute expected signature
    signed_payload = f"{timestamp}.{payload}"
    expected = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()

    # Timing-safe comparison
    return hmac.compare_digest(expected, sig)

if __name__ == '__main__':
    app.run(port=3000)
```
</CodeGroup>

## Next Steps

<CardGroup cols={2}>
<Card title="Understand Core Concepts" icon="book" href="/concepts/authentication">
  Deep dive into authentication, user linking, and credits
</Card>

<Card title="Explore API Reference" icon="code" href="/api/reference">
  Complete documentation of all API endpoints
</Card>

<Card title="Configure Webhooks" icon="webhook" href="/webhooks/overview">
  Learn about webhook events and best practices
</Card>

<Card title="View More Examples" icon="file-code" href="/examples/node">
  Browse complete examples in multiple languages
</Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
<Accordion title="Email Lookup Returns 404">
  **Possible causes:**
  - User hasn't subscribed to your tool on 1Sub yet
  - Email addresses don't match (check capitalization/whitespace)
  - User subscribed with different email address

  **Solution:** Ensure the email is normalized (lowercase, trimmed) and matches the 1Sub subscription email. Consider using link codes as fallback.
</Accordion>

<Accordion title="Link Code Invalid or Expired">
  **Possible causes:**
  - Code has expired (10 minute lifetime)
  - Code was already used
  - Code was entered incorrectly

  **Solution:** Prompt user to generate a new code from their 1Sub account settings. Validate code format before calling API.
</Accordion>

<Accordion title="Subscription Not Found (404)">
  **Possible causes:**
  - User hasn't subscribed yet
  - Wrong `oneSubUserId`
  - Account not properly linked

  **Solution:** Check the user link mapping in your database. Ask user to re-link their account.
</Accordion>

<Accordion title="Webhook Signature Invalid">
  **Possible causes:**
  - Using parsed body instead of raw body
  - Wrong webhook secret
  - Timestamp too old (>5 minutes)

  **Solution:** Use `express.raw()` middleware and verify your webhook secret is correct in environment variables.
</Accordion>

<Accordion title="Rate Limit Exceeded for Email Lookups">
  **Possible causes:**
  - Making too many email hash lookups (30/min limit)
  - Not caching oneSubUserId after first lookup

  **Solution:** Always cache `oneSubUserId` after the first email lookup. Use the cached value for subsequent verifications (100/min limit).
</Accordion>
</AccordionGroup>

<Warning>
Always store your API key and webhook secret securely in environment variables. Never commit them to version control.
</Warning>
